From 7ad1a48aeb66ced56690d9eb90f35a0632b4d4bf Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Thu, 27 Jul 2023 08:00:43 -0700
Subject: [PATCH 01/25] ntdll: Implement WOW64 thread suspension helpers.

---
 dlls/ntdll/loader.c         |  2 ++
 dlls/ntdll/ntdll.spec       |  1 +
 dlls/ntdll/ntdll_misc.h     |  1 +
 dlls/ntdll/signal_arm64.c   | 17 +++++++++++++++++
 dlls/ntdll/signal_arm64ec.c |  7 +++++++
 dlls/ntdll/signal_x86_64.c  |  7 +++++++
 include/winternl.h          |  1 +
 7 files changed, 36 insertions(+)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 6b089c990b57..7a307b33f22b 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -4273,6 +4273,7 @@ static void build_wow64_main_module(void)
 static void (WINAPI *pWow64LdrpInitialize)( CONTEXT *ctx );
 
 void (WINAPI *pWow64PrepareForException)( EXCEPTION_RECORD *rec, CONTEXT *context ) = NULL;
+NTSTATUS (WINAPI *pWow64SuspendLocalThread)( HANDLE thread, ULONG *count ) = NULL;
 
 static void init_wow64( CONTEXT *context )
 {
@@ -4297,6 +4298,7 @@ static void init_wow64( CONTEXT *context )
 
         GET_PTR( Wow64LdrpInitialize );
         GET_PTR( Wow64PrepareForException );
+        GET_PTR( Wow64SuspendLocalThread );
 #undef GET_PTR
         imports_fixup_done = TRUE;
     }
diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index 8d14ae393be2..93ef6c2e0a38 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -1142,6 +1142,7 @@
 @ stdcall -arch=win64 RtlWow64PushCrossProcessWorkOntoWorkList(ptr ptr ptr)
 @ stdcall -arch=win64 RtlWow64RequestCrossProcessHeavyFlush(ptr)
 @ stdcall -arch=win64 RtlWow64SetThreadContext(long ptr)
+@ stdcall -arch=win64 RtlWow64SuspendThread(long ptr)
 @ stub RtlWriteMemoryStream
 @ stdcall RtlWriteRegistryValue(long ptr wstr long ptr long)
 @ stub RtlZeroHeap
diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
index 99e0aceeef30..d8de8fb32e91 100644
--- a/dlls/ntdll/ntdll_misc.h
+++ b/dlls/ntdll/ntdll_misc.h
@@ -76,6 +76,7 @@ extern void WINAPI KiUserApcDispatcher(CONTEXT*,ULONG_PTR,ULONG_PTR,ULONG_PTR,PN
 extern void WINAPI KiUserCallbackDispatcher(ULONG,void*,ULONG);
 extern void WINAPI KiUserCallbackDispatcherReturn(void);
 extern void (WINAPI *pWow64PrepareForException)( EXCEPTION_RECORD *rec, CONTEXT *context );
+extern NTSTATUS (WINAPI *pWow64SuspendLocalThread)( HANDLE thread, ULONG *count );
 
 /* debug helpers */
 extern LPCSTR debugstr_us( const UNICODE_STRING *str );
diff --git a/dlls/ntdll/signal_arm64.c b/dlls/ntdll/signal_arm64.c
index bc981289ea5a..548f87a3a6ee 100644
--- a/dlls/ntdll/signal_arm64.c
+++ b/dlls/ntdll/signal_arm64.c
@@ -643,6 +643,23 @@ BOOLEAN WINAPI RtlIsProcessorFeaturePresent( UINT feature )
             user_shared_data->ProcessorFeatures[feature]);
 }
 
+/***********************************************************************
+ *              RtlWow64SuspendThread (NTDLL.@)
+ */
+NTSTATUS WINAPI RtlWow64SuspendThread( HANDLE thread, ULONG *count )
+{
+    THREAD_BASIC_INFORMATION tbi;
+
+    NTSTATUS ret = NtQueryInformationThread( thread, ThreadBasicInformation, &tbi, sizeof(tbi), NULL);
+    if (ret) return ret;
+
+    if (tbi.ClientId.UniqueProcess != NtCurrentTeb()->ClientId.UniqueProcess) {
+        FIXME( "Non-local process thread suspend\n" );
+        return STATUS_SUCCESS;
+    }
+
+    return pWow64SuspendLocalThread( thread, count );
+}
 
 /*************************************************************************
  *		RtlWalkFrameChain (NTDLL.@)
diff --git a/dlls/ntdll/signal_arm64ec.c b/dlls/ntdll/signal_arm64ec.c
index 1cb587fa4476..241b940219cc 100644
--- a/dlls/ntdll/signal_arm64ec.c
+++ b/dlls/ntdll/signal_arm64ec.c
@@ -1768,6 +1768,13 @@ BOOLEAN WINAPI RtlIsProcessorFeaturePresent( UINT feature )
     return emulated_processor_features[feature];
 }
 
+/***********************************************************************
+ *              RtlWow64SuspendThread (NTDLL.@)
+ */
+NTSTATUS WINAPI RtlWow64SuspendThread( HANDLE thread, ULONG *count )
+{
+    return NtSuspendThread( thread, count );
+}
 
 /*************************************************************************
  *		RtlWalkFrameChain (NTDLL.@)
diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
index ad9557ca9062..2e5980529cac 100644
--- a/dlls/ntdll/signal_x86_64.c
+++ b/dlls/ntdll/signal_x86_64.c
@@ -844,6 +844,13 @@ BOOLEAN WINAPI RtlIsProcessorFeaturePresent( UINT feature )
     return feature < PROCESSOR_FEATURE_MAX && user_shared_data->ProcessorFeatures[feature];
 }
 
+/***********************************************************************
+ *              RtlWow64SuspendThread (NTDLL.@)
+ */
+NTSTATUS WINAPI RtlWow64SuspendThread( HANDLE thread, ULONG *count )
+{
+    return NtSuspendThread( thread, count );
+}
 
 /*************************************************************************
  *		RtlWalkFrameChain (NTDLL.@)
diff --git a/include/winternl.h b/include/winternl.h
index 0bf166b89963..9bc5d0dac033 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -5110,6 +5110,7 @@ NTSYSAPI USHORT    WINAPI RtlWow64GetCurrentMachine(void);
 NTSYSAPI NTSTATUS  WINAPI RtlWow64GetProcessMachines(HANDLE,USHORT*,USHORT*);
 NTSYSAPI NTSTATUS  WINAPI RtlWow64GetSharedInfoProcess(HANDLE,BOOLEAN*,WOW64INFO*);
 NTSYSAPI NTSTATUS  WINAPI RtlWow64IsWowGuestMachineSupported(USHORT,BOOLEAN*);
+NTSYSAPI NTSTATUS  WINAPI RtlWow64SuspendThread(HANDLE,ULONG*);
 NTSYSAPI NTSTATUS  WINAPI RtlWriteRegistryValue(ULONG,PCWSTR,PCWSTR,ULONG,PVOID,ULONG);
 NTSYSAPI NTSTATUS  WINAPI RtlZombifyActivationContext(struct _ACTIVATION_CONTEXT *);
 NTSYSAPI NTSTATUS  WINAPI RtlpNtCreateKey(PHANDLE,ACCESS_MASK,const OBJECT_ATTRIBUTES*,ULONG,const UNICODE_STRING*,ULONG,PULONG);

From 3954e1dc9af1a36a6024c04d11fa3099c9f9662c Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Thu, 27 Jul 2023 08:20:59 -0700
Subject: [PATCH 02/25] wow64: Support running a BT module provided suspend
 routine.

Suspension in JITs cannot easily be handled on the unix side, so allow BT
modules to provide their own suspend helper.
---
 dlls/wow64/process.c  |  2 +-
 dlls/wow64/syscall.c  | 10 ++++++++++
 dlls/wow64/wow64.spec |  2 +-
 3 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/dlls/wow64/process.c b/dlls/wow64/process.c
index 957ca0d2691e..7b214d770eb6 100644
--- a/dlls/wow64/process.c
+++ b/dlls/wow64/process.c
@@ -1079,7 +1079,7 @@ NTSTATUS WINAPI wow64_NtSuspendThread( UINT *args )
     HANDLE handle = get_handle( &args );
     ULONG *count = get_ptr( &args );
 
-    return NtSuspendThread( handle, count );
+    return RtlWow64SuspendThread( handle, count );
 }
 
 
diff --git a/dlls/wow64/syscall.c b/dlls/wow64/syscall.c
index d2a977ee5adb..fbc687cc02a2 100644
--- a/dlls/wow64/syscall.c
+++ b/dlls/wow64/syscall.c
@@ -102,6 +102,7 @@ static void     (WINAPI *pBTCpuProcessInit)(void);
 static NTSTATUS (WINAPI *pBTCpuSetContext)(HANDLE,HANDLE,void *,void *);
 static void     (WINAPI *pBTCpuThreadInit)(void);
 static void     (WINAPI *pBTCpuSimulate)(void) __attribute__((used));
+static NTSTATUS (WINAPI *pBTCpuSuspendLocalThread)(HANDLE,ULONG *);
 static void *   (WINAPI *p__wine_get_unix_opcode)(void);
 static void *   (WINAPI *pKiRaiseUserExceptionDispatcher)(void);
 void     (WINAPI *pBTCpuFlushInstructionCache2)( const void *, SIZE_T ) = NULL;
@@ -839,6 +840,7 @@ static DWORD WINAPI process_init( RTL_RUN_ONCE *once, void *param, void **contex
     GET_PTR( BTCpuProcessInit );
     GET_PTR( BTCpuThreadInit );
     GET_PTR( BTCpuResetToConsistentState );
+    GET_PTR( BTCpuSuspendLocalThread );
     GET_PTR( BTCpuSetContext );
     GET_PTR( BTCpuSimulate );
     GET_PTR( BTCpuFlushInstructionCache2 );
@@ -1525,3 +1527,11 @@ NTSTATUS WINAPI Wow64RaiseException( int code, EXCEPTION_RECORD *rec )
 
     return STATUS_SUCCESS;
 }
+
+/**********************************************************************
+ *            Wow64SuspendLocalThread (wow64.@)
+ */
+NTSTATUS WINAPI Wow64SuspendLocalThread( HANDLE thread, ULONG *count )
+{
+    return pBTCpuSuspendLocalThread( thread, count );
+}
diff --git a/dlls/wow64/wow64.spec b/dlls/wow64/wow64.spec
index 5b4e565e5936..8f95dfcdbe52 100644
--- a/dlls/wow64/wow64.spec
+++ b/dlls/wow64/wow64.spec
@@ -22,7 +22,7 @@
 @ stub Wow64ShallowThunkAllocSecurityQualityOfService32TO64_FNC
 @ stub Wow64ShallowThunkSIZE_T32TO64
 @ stub Wow64ShallowThunkSIZE_T64TO32
-@ stub Wow64SuspendLocalThread
+@ stdcall Wow64SuspendLocalThread(long ptr)
 @ stdcall -norelay Wow64SystemServiceEx(long ptr)
 @ stub Wow64ValidateUserCallTarget
 @ stub Wow64ValidateUserCallTargetFilter

From b8c024a07691ee8a1de34ccd3ec8342c4f73de8b Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Fri, 12 Apr 2024 20:54:16 +0000
Subject: [PATCH 03/25] HACK: server: Map within the 39-bit address space on
 arm64.

---
 server/mapping.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/server/mapping.c b/server/mapping.c
index c3f57b6394c1..11ee3e7f858e 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -269,7 +269,11 @@ void init_memory(void)
 {
     host_page_mask = sysconf( _SC_PAGESIZE ) - 1;
     free_map_addr( 0x60000000, 0x1c000000 );
+#ifdef __aarch64__
+    free_map_addr( 0x4000000000, 0x1000000000 );
+#else
     free_map_addr( 0x600000000000, 0x100000000000 );
+#endif
 }
 
 static void ranges_dump( struct object *obj, int verbose )

From 827478adaceac388fc19f934683d305adc406d48 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Wed, 17 Apr 2024 18:50:05 +0000
Subject: [PATCH 04/25] ntdll: Force all wow64 host allocations outside of the
 32-bit AS.

---
 dlls/ntdll/unix/virtual.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index e733e3ffdd66..cb060605205c 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -4960,6 +4960,9 @@ static NTSTATUS allocate_virtual_memory( void **ret, SIZE_T *size_ptr, ULONG typ
     {
         base = NULL;
         size = ROUND_SIZE( 0, size, page_mask );
+#ifdef _WIN64
+        if (is_wow64() && (!limit_high || limit_high > limit_4g)) limit_low = limit_4g;
+#endif
     }
 
     /* Compute the alloc type flags */

From 820d2aa8d7ae7fe9c5fab2618e903b9124504934 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Fri, 19 Apr 2024 20:25:30 +0000
Subject: [PATCH 05/25] HACK: Use x86 mono on aarch64.

---
 dlls/appwiz.cpl/addons.c | 4 ++--
 dlls/mscoree/metahost.c  | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/dlls/appwiz.cpl/addons.c b/dlls/appwiz.cpl/addons.c
index 65d13a66c344..49428a7b64fa 100644
--- a/dlls/appwiz.cpl/addons.c
+++ b/dlls/appwiz.cpl/addons.c
@@ -48,7 +48,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(appwizcpl);
 #ifdef __i386__
 #define GECKO_ARCH "x86"
 #define GECKO_SHA "26cecc47706b091908f7f814bddb074c61beb8063318e9efc5a7f789857793d6"
-#elif defined(__x86_64__)
+#elif defined(__x86_64__) || defined(__aarch64__)
 #define GECKO_ARCH "x86_64"
 #define GECKO_SHA "e590b7d988a32d6aa4cf1d8aa3aa3d33766fdd4cf4c89c2dcc2095ecb28d066f"
 #else
@@ -57,7 +57,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(appwizcpl);
 #endif
 
 #define MONO_VERSION "10.1.0"
-#if defined(__i386__) || defined(__x86_64__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__aarch64__)
 #define MONO_ARCH "x86"
 #define MONO_SHA "c88c2431890bc32cacec8d7ea70e53a5ae4b95c8c55ca6e75ef8db0e4ccf1070"
 #else
diff --git a/dlls/mscoree/metahost.c b/dlls/mscoree/metahost.c
index 0e34d7388a0f..a4ff9fd90268 100644
--- a/dlls/mscoree/metahost.c
+++ b/dlls/mscoree/metahost.c
@@ -711,7 +711,7 @@ HRESULT ICLRRuntimeInfo_GetRuntimeHost(ICLRRuntimeInfo *iface, RuntimeHost **res
 
 #ifdef __i386__
 static const WCHAR libmono2_arch_dll[] = {'\\','b','i','n','\\','l','i','b','m','o','n','o','-','2','.','0','-','x','8','6','.','d','l','l',0};
-#elif defined(__x86_64__)
+#elif defined(__x86_64__) || defined(__aarch64__)
 static const WCHAR libmono2_arch_dll[] = {'\\','b','i','n','\\','l','i','b','m','o','n','o','-','2','.','0','-','x','8','6','_','6','4','.','d','l','l',0};
 #else
 static const WCHAR libmono2_arch_dll[] = {'\\','b','i','n','\\','l','i','b','m','o','n','o','-','2','.','0','.','d','l','l',0};

From 1ea024550725f44237121ec0e687434de1e81cb3 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Tue, 23 Apr 2024 12:58:04 +0000
Subject: [PATCH 06/25] configure: Enable vcruntime140_1 and dpnsvcr for arm64x
 builds.

---
 configure.ac                            | 4 ++--
 dlls/vcruntime140_1/vcruntime140_1.spec | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/configure.ac b/configure.ac
index b4ede761391f..332fd641986d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2371,7 +2371,7 @@ esac
 
 dnl *** Check for modules to disable by default
 
-enable_vcruntime140_1=${enable_vcruntime140_1:-x86_64,arm64ec}
+enable_vcruntime140_1=${enable_vcruntime140_1:-x86_64,arm64ec,aarch64}
 
 if test -n "$PE_ARCHS"
 then
@@ -2401,7 +2401,7 @@ enable_wuauserv=${enable_wuauserv:-$HOST_ARCH}
 dnl Explicitly enable some programs for arm64ec
 enable_cmd=${enable_cmd:-yes}
 enable_dllhost=${enable_dllhost:-yes}
-enable_dpnsvr=${enable_dpnsvr:-i386,x86_64,arm64ec}
+enable_dpnsvr=${enable_dpnsvr:-i386,x86_64,arm64ec,aarch64}
 enable_dxdiag=${enable_dxdiag:-yes}
 enable_msiexec=${enable_msiexec:-yes}
 enable_netsh=${enable_netsh:-yes}
diff --git a/dlls/vcruntime140_1/vcruntime140_1.spec b/dlls/vcruntime140_1/vcruntime140_1.spec
index 0b126fa95d46..af295940a61a 100644
--- a/dlls/vcruntime140_1/vcruntime140_1.spec
+++ b/dlls/vcruntime140_1/vcruntime140_1.spec
@@ -1,3 +1,3 @@
-@ cdecl __CxxFrameHandler4(ptr long ptr ptr)
+@ cdecl -arch=arm64ec,x86_64 __CxxFrameHandler4(ptr long ptr ptr)
 @ stub __NLG_Dispatch2
 @ stub __NLG_Return2

From 1329ca33abad59761abdbe33ef8d0c6fa2eca897 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Mon, 19 Aug 2024 20:29:50 +0000
Subject: [PATCH 07/25] include: Add arm64 SVE xstate headers.

---
 include/winnt.h | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/include/winnt.h b/include/winnt.h
index 529f6d17bb80..fafd82a4d810 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -1473,6 +1473,10 @@ typedef struct _KNONVOLATILE_CONTEXT_POINTERS
 #define XSTATE_MASK_LEGACY                  (XSTATE_MASK_LEGACY_FLOATING_POINT | XSTATE_MASK_LEGACY_SSE)
 #define XSTATE_MASK_GSSE                    (1 << XSTATE_GSSE)
 
+#define XSTATE_ARM64_SVE 2
+
+#define XSTATE_MASK_ARM64_SVE (1 << XSTATE_ARM64_SVE)
+
 typedef struct _XSTATE_FEATURE
 {
     ULONG Offset;
@@ -1513,6 +1517,13 @@ typedef struct _XSAVE_AREA_HEADER
 }
 XSAVE_AREA_HEADER, *PXSAVE_AREA_HEADER;
 
+typedef struct _XSAVE_ARM64_SVE_HEADER {
+    ULONG VectorLength;
+    ULONG VectorRegisterOffset;
+    ULONG PredicateRegisterOffset;
+    ULONG Reserved[5];
+} XSAVE_ARM64_SVE_HEADER, *PXSAVE_ARM64_SVE_HEADER;
+
 typedef struct _YMMCONTEXT
 {
     M128A Ymm0;
@@ -1693,6 +1704,7 @@ typedef struct _KNONVOLATILE_CONTEXT_POINTERS
 #define CONTEXT_ARM64_FLOATING_POINT  (CONTEXT_ARM64 | 0x00000004)
 #define CONTEXT_ARM64_DEBUG_REGISTERS (CONTEXT_ARM64 | 0x00000008)
 #define CONTEXT_ARM64_X18       (CONTEXT_ARM64 | 0x00000010)
+#define CONTEXT_ARM64_XSTATE    (CONTEXT_ARM64 | 0x00000020)
 #define CONTEXT_ARM64_FULL (CONTEXT_ARM64_CONTROL | CONTEXT_ARM64_INTEGER | CONTEXT_ARM64_FLOATING_POINT)
 #define CONTEXT_ARM64_ALL  (CONTEXT_ARM64_FULL | CONTEXT_ARM64_DEBUG_REGISTERS | CONTEXT_ARM64_X18)
 
@@ -1972,6 +1984,7 @@ typedef struct DECLSPEC_ALIGN(16) _ARM64EC_NT_CONTEXT
 #define CONTEXT_INTEGER CONTEXT_ARM64_INTEGER
 #define CONTEXT_FLOATING_POINT CONTEXT_ARM64_FLOATING_POINT
 #define CONTEXT_DEBUG_REGISTERS CONTEXT_ARM64_DEBUG_REGISTERS
+#define CONTEXT_XSTATE CONTEXT_ARM64_XSTATE
 #define CONTEXT_FULL CONTEXT_ARM64_FULL
 #define CONTEXT_ALL CONTEXT_ARM64_ALL
 #define CONTEXT_RET_TO_GUEST CONTEXT_ARM64_RET_TO_GUEST

From caf5147defd1586bca534de4a90352d74d2604fa Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Wed, 21 Aug 2024 22:26:28 +0000
Subject: [PATCH 08/25] FEX specific AVX support for arm64ec

---
 dlls/ntdll/signal_arm64ec.c | 56 ++++++++++++++++++++++++-------------
 dlls/ntdll/signal_x86_64.c  |  2 +-
 dlls/ntdll/unix/system.c    | 19 +++++++++++++
 dlls/ntdll/unwind.h         | 16 +++++++++++
 include/winnt.h             |  5 ++--
 5 files changed, 75 insertions(+), 23 deletions(-)

diff --git a/dlls/ntdll/signal_arm64ec.c b/dlls/ntdll/signal_arm64ec.c
index 241b940219cc..09b1050a65a8 100644
--- a/dlls/ntdll/signal_arm64ec.c
+++ b/dlls/ntdll/signal_arm64ec.c
@@ -36,6 +36,11 @@
 #include "wine/debug.h"
 #include "ntsyscalls.h"
 
+union ARM64EC_NT_XCONTEXT {
+    ARM64EC_NT_CONTEXT context;
+    BYTE buffer[0x800];
+};
+
 WINE_DEFAULT_DEBUG_CHANNEL(seh);
 WINE_DECLARE_DEBUG_CHANNEL(relay);
 
@@ -1220,7 +1225,11 @@ NTSTATUS call_seh_handlers( EXCEPTION_RECORD *rec, CONTEXT *orig_context )
  */
 void dispatch_emulation( ARM64_NT_CONTEXT *arm_ctx )
 {
-    context_arm_to_x64( get_arm64ec_cpu_area()->ContextAmd64, arm_ctx );
+    ARM64EC_NT_CONTEXT *context = get_arm64ec_cpu_area()->ContextAmd64;
+    CONTEXT_EX *xctx;
+
+    RtlInitializeExtendedContext( context, ctx_flags_arm_to_x64( arm_ctx->ContextFlags), &xctx );
+    context_arm_to_x64( context, arm_ctx );
     get_arm64ec_cpu_area()->InSimulation = 1;
     pBeginSimulation();
 }
@@ -1250,11 +1259,13 @@ static void dispatch_syscall( ARM64_NT_CONTEXT *context )
 }
 
 
-static void * __attribute__((used)) prepare_exception_arm64ec( EXCEPTION_RECORD *rec, ARM64EC_NT_CONTEXT *context, ARM64_NT_CONTEXT *arm_ctx )
+static void * __attribute__((used)) prepare_exception_arm64ec( EXCEPTION_RECORD *rec, union ARM64EC_NT_XCONTEXT *context, ARM64_NT_CONTEXT *arm_ctx )
 {
+    CONTEXT_EX *xctx;
     if (rec->ExceptionCode == STATUS_EMULATION_SYSCALL) dispatch_syscall( arm_ctx );
-    context_arm_to_x64( context, arm_ctx );
-    if (pResetToConsistentState) pResetToConsistentState( rec, &context->AMD64_Context, arm_ctx );
+    RtlInitializeExtendedContext( context, ctx_flags_arm_to_x64( arm_ctx->ContextFlags ), &xctx );
+    context_arm_to_x64( &context->context, arm_ctx );
+    if (pResetToConsistentState) pResetToConsistentState( rec, &context->context.AMD64_Context, arm_ctx );
     /* call x64 dispatcher if the thunk or the function pointer was modified */
     if (pWow64PrepareForException || memcmp( KiUserExceptionDispatcher_thunk, KiUserExceptionDispatcher_orig,
                                              sizeof(KiUserExceptionDispatcher_orig) ))
@@ -1269,12 +1280,13 @@ void __attribute__((naked)) KiUserExceptionDispatcher( EXCEPTION_RECORD *rec, CO
 {
     asm( ".seh_proc \"#KiUserExceptionDispatcher\"\n\t"
          ".seh_context\n\t"
-         "sub sp, sp, #0x4d0\n\t"       /* sizeof(ARM64EC_NT_CONTEXT) */
-         ".seh_stackalloc 0x4d0\n\t"
+         "sub sp, sp, #0xcd0\n\t"       /* sizeof(union ARM64EC_NT_XCONTEXT) */
+         ".seh_stackalloc 0xcd0\n\t"
          ".seh_endprologue\n\t"
-         "add x0, sp, #0x3b0+0x4d0\n\t" /* rec */
+         "add x0, sp, #0xcd0\n\t"
+         "add x0, x0, #0x3b0\n\t"       /* rec */
          "mov x1, sp\n\t"               /* context */
-         "add x2, sp, #0x4d0\n\t"       /* arm_ctx (context + 1) */
+         "add x2, sp, #0xcd0\n\t"       /* arm_ctx (context + 1) */
          "bl \"#prepare_exception_arm64ec\"\n\t"
          "cbz x0, 1f\n\t"
          /* bypass exit thunk to avoid messing up the stack */
@@ -1282,8 +1294,9 @@ void __attribute__((naked)) KiUserExceptionDispatcher( EXCEPTION_RECORD *rec, CO
          "ldr x16, [x16, #:lo12:__os_arm64x_dispatch_call_no_redirect]\n\t"
          "mov x9, x0\n\t"
          "blr x16\n"
-         "1:\tadd x0, sp, #0x3b0+0x4d0\n\t" /* rec */
-         "mov x1, sp\n\t"                   /* context */
+         "1:\tadd x0, sp, #0xcd0\n\t"
+         "add x0, x0, #0x3b0\n\t"       /* rec */
+         "mov x1, sp\n\t"               /* context */
          "bl #dispatch_exception\n\t"
          "brk #1\n\t"
          ".seh_endproc" );
@@ -1297,11 +1310,12 @@ static void __attribute__((used)) dispatch_apc( void (CALLBACK *func)(ULONG_PTR,
                                                 ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3,
                                                 BOOLEAN alertable, ARM64_NT_CONTEXT *arm_ctx )
 {
-    ARM64EC_NT_CONTEXT context;
-
-    context_arm_to_x64( &context, arm_ctx );
-    func( arg1, arg2, arg3, &context.AMD64_Context );
-    NtContinue( &context.AMD64_Context, alertable );
+    union ARM64EC_NT_XCONTEXT context;
+    CONTEXT_EX *xctx;
+    RtlInitializeExtendedContext( &context, ctx_flags_arm_to_x64( arm_ctx->ContextFlags), &xctx );
+    context_arm_to_x64( &context.context, arm_ctx );
+    func( arg1, arg2, arg3, &context.context.AMD64_Context );
+    NtContinue( &context.context.AMD64_Context, alertable );
 }
 __ASM_GLOBAL_FUNC( "#KiUserApcDispatcher",
                    ".seh_context\n\t"
@@ -2056,7 +2070,9 @@ void __attribute__((naked)) RtlUserThreadStart( PRTL_THREAD_START_ROUTINE entry,
  */
 void WINAPI LdrInitializeThunk( CONTEXT *arm_context, ULONG_PTR unk2, ULONG_PTR unk3, ULONG_PTR unk4 )
 {
-    ARM64EC_NT_CONTEXT context;
+    union ARM64EC_NT_XCONTEXT context;
+    CONTEXT_EX *xctx;
+    RtlInitializeExtendedContext( &context, ctx_flags_arm_to_x64( arm_context->ContextFlags), &xctx );
 
     if (!__os_arm64x_check_call)
     {
@@ -2067,10 +2083,10 @@ void WINAPI LdrInitializeThunk( CONTEXT *arm_context, ULONG_PTR unk2, ULONG_PTR
         __os_arm64x_set_x64_information = LdrpSetX64Information;
     }
 
-    context_arm_to_x64( &context, (ARM64_NT_CONTEXT *)arm_context );
-    loader_init( &context.AMD64_Context, (void **)&context.X0 );
-    TRACE_(relay)( "\1Starting thread proc %p (arg=%p)\n", (void *)context.X0, (void *)context.X1 );
-    NtContinue( &context.AMD64_Context, TRUE );
+    context_arm_to_x64( &context.context, (ARM64_NT_CONTEXT *)arm_context );
+    loader_init( &context.context.AMD64_Context, (void **)&context.context.X0 );
+    TRACE_(relay)( "\1Starting thread proc %p (arg=%p)\n", (void *)context.context.X0, (void *)context.context.X1 );
+    NtContinue( &context.context.AMD64_Context, TRUE );
 }
 
 
diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
index 2e5980529cac..41a3c612c62b 100644
--- a/dlls/ntdll/signal_x86_64.c
+++ b/dlls/ntdll/signal_x86_64.c
@@ -83,7 +83,7 @@ __ASM_GLOBAL_FUNC( "EXP+#KiUserExceptionDispatcher",
                    "test %rax,%rax\n\t"
                    "jz 1f\n\t"
                    "subq $0x28,%rsp\n\t"
-                   "leaq 0x30+0x3b0+0x4d0(%rsp),%rcx\n\t" /* rec */
+                   "leaq 0x30+0x3b0+0xcd0(%rsp),%rcx\n\t" /* rec */
                    "leaq 0x30(%rsp),%rdx\n\t"             /* context */
                    "call *%rax\n"
                    "addq $0x28,%rsp\n"
diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
index e486da406918..78414049182e 100644
--- a/dlls/ntdll/unix/system.c
+++ b/dlls/ntdll/unix/system.c
@@ -597,6 +597,23 @@ static ULONGLONG get_cpu_features(void)
     return 0;  /* FIXME */
 }
 
+static void init_xstate_features( XSTATE_CONFIGURATION *xstate )
+{
+    xstate->EnabledFeatures = (1 << XSTATE_LEGACY_FLOATING_POINT) | (1 << XSTATE_LEGACY_SSE) | (1 << XSTATE_AVX);
+    xstate->EnabledVolatileFeatures = xstate->EnabledFeatures;
+    xstate->AllFeatureSize = 0x340;
+
+    xstate->OptimizedSave = 0;
+    xstate->CompactionEnabled = 0;
+
+    xstate->Features[0].Size = xstate->AllFeatures[0] = offsetof(XSAVE_FORMAT, XmmRegisters);
+    xstate->Features[1].Size = xstate->AllFeatures[1] = sizeof(M128A) * 16;
+    xstate->Features[1].Offset = xstate->Features[0].Size;
+    xstate->Features[2].Offset = 0x240;
+    xstate->Features[2].Size = 0x100;
+    xstate->Size = 0x340;
+}
+
 void init_shared_data_cpuinfo( KUSER_SHARED_DATA *data )
 {
     BOOLEAN *features = data->ProcessorFeatures;
@@ -679,6 +696,8 @@ void init_shared_data_cpuinfo( KUSER_SHARED_DATA *data )
             break;
         }
     }
+
+    init_xstate_features( &data->XState );
 }
 
 #endif /* End architecture specific feature detection for CPUs */
diff --git a/dlls/ntdll/unwind.h b/dlls/ntdll/unwind.h
index faca8a259fb6..71a4d23da043 100644
--- a/dlls/ntdll/unwind.h
+++ b/dlls/ntdll/unwind.h
@@ -36,6 +36,7 @@ static inline ULONG ctx_flags_x64_to_arm( ULONG flags )
     if (flags & CONTEXT_AMD64_CONTROL) ret |= CONTEXT_ARM64_CONTROL;
     if (flags & CONTEXT_AMD64_INTEGER) ret |= CONTEXT_ARM64_INTEGER;
     if (flags & CONTEXT_AMD64_FLOATING_POINT) ret |= CONTEXT_ARM64_FLOATING_POINT;
+    if (flags & CONTEXT_AMD64_XSTATE) ret |= CONTEXT_ARM64_FEX_YMMSTATE;
     return ret;
 }
 
@@ -47,6 +48,7 @@ static inline ULONG ctx_flags_arm_to_x64( ULONG flags )
     if (flags & CONTEXT_ARM64_CONTROL) ret |= CONTEXT_AMD64_CONTROL;
     if (flags & CONTEXT_ARM64_INTEGER) ret |= CONTEXT_AMD64_INTEGER;
     if (flags & CONTEXT_ARM64_FLOATING_POINT) ret |= CONTEXT_AMD64_FLOATING_POINT;
+    if (flags & CONTEXT_ARM64_FEX_YMMSTATE) ret |= CONTEXT_AMD64_XSTATE;
     return ret;
 }
 
@@ -166,6 +168,13 @@ static inline void context_x64_to_arm( ARM64_NT_CONTEXT *arm_ctx, const ARM64EC_
     fpcsr = mxcsr_to_fpcsr( ec_ctx->AMD64_MxCsr );
     arm_ctx->Fpcr = fpcsr;
     arm_ctx->Fpsr = fpcsr >> 32;
+
+    if ((ec_ctx->ContextFlags & CONTEXT_XSTATE) == CONTEXT_XSTATE)
+    {
+        CONTEXT_EX *ec_xctx = (CONTEXT_EX *)(ec_ctx + 1);
+        YMMCONTEXT *ec_ymm = RtlLocateExtendedFeature( ec_xctx, XSTATE_AVX, NULL );
+        memcpy( arm_ctx->V + 16, ec_ymm, sizeof(*ec_ymm) );
+    }
 }
 
 static inline void context_arm_to_x64( ARM64EC_NT_CONTEXT *ec_ctx, const ARM64_NT_CONTEXT *arm_ctx )
@@ -216,6 +225,13 @@ static inline void context_arm_to_x64( ARM64EC_NT_CONTEXT *ec_ctx, const ARM64_N
     ec_ctx->X17_3 = arm_ctx->X17 >> 48;
 
     memcpy( ec_ctx->V, arm_ctx->V, sizeof(ec_ctx->V) );
+
+    if ((arm_ctx->ContextFlags & CONTEXT_ARM64_FEX_YMMSTATE) == CONTEXT_ARM64_FEX_YMMSTATE)
+    {
+        CONTEXT_EX *ec_xctx = (CONTEXT_EX *)(ec_ctx + 1);
+        YMMCONTEXT *ec_ymm = RtlLocateExtendedFeature( ec_xctx, XSTATE_AVX, NULL );
+        memcpy( ec_ymm, arm_ctx->V + 16, sizeof(*ec_ymm) );
+    }
 }
 
 #endif /* __aarch64__ || __arm64ec__ */
diff --git a/include/winnt.h b/include/winnt.h
index fafd82a4d810..6cef4b69daef 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -1703,8 +1703,9 @@ typedef struct _KNONVOLATILE_CONTEXT_POINTERS
 #define CONTEXT_ARM64_INTEGER         (CONTEXT_ARM64 | 0x00000002)
 #define CONTEXT_ARM64_FLOATING_POINT  (CONTEXT_ARM64 | 0x00000004)
 #define CONTEXT_ARM64_DEBUG_REGISTERS (CONTEXT_ARM64 | 0x00000008)
-#define CONTEXT_ARM64_X18       (CONTEXT_ARM64 | 0x00000010)
-#define CONTEXT_ARM64_XSTATE    (CONTEXT_ARM64 | 0x00000020)
+#define CONTEXT_ARM64_X18             (CONTEXT_ARM64 | 0x00000010)
+#define CONTEXT_ARM64_XSTATE          (CONTEXT_ARM64 | 0x00000020)
+#define CONTEXT_ARM64_FEX_YMMSTATE   (CONTEXT_ARM64 | 0x00000040)
 #define CONTEXT_ARM64_FULL (CONTEXT_ARM64_CONTROL | CONTEXT_ARM64_INTEGER | CONTEXT_ARM64_FLOATING_POINT)
 #define CONTEXT_ARM64_ALL  (CONTEXT_ARM64_FULL | CONTEXT_ARM64_DEBUG_REGISTERS | CONTEXT_ARM64_X18)
 

From 76b6f74ce820f4c1194d1a5a8cf74ce1e36f4e0a Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Wed, 17 Apr 2024 23:44:33 +0000
Subject: [PATCH 09/25] Use FEX wow64/ARM64EC dll names

---
 dlls/ntdll/loader.c  | 3 +--
 dlls/wow64/syscall.c | 2 +-
 loader/wine.inf.in   | 4 ++--
 3 files changed, 4 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 7a307b33f22b..c9a91f192b69 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -4223,7 +4223,7 @@ static void load_arm64ec_module(void)
     ULONG buffer[16];
     KEY_VALUE_PARTIAL_INFORMATION *info = (KEY_VALUE_PARTIAL_INFORMATION *)buffer;
     UNICODE_STRING nameW = RTL_CONSTANT_STRING( L"\\Registry\\Machine\\Software\\Microsoft\\Wow64\\amd64" );
-    WCHAR module[64] = L"C:\\windows\\system32\\xtajit64.dll";
+    WCHAR module[64] = L"C:\\windows\\system32\\libarm64ecfex.dll";
     OBJECT_ATTRIBUTES attr;
     WINE_MODREF *wm;
     NTSTATUS status;
@@ -4307,7 +4307,6 @@ static void init_wow64( CONTEXT *context )
     pWow64LdrpInitialize( context );
 }
 
-
 #else
 
 void *Wow64Transition = NULL;
diff --git a/dlls/wow64/syscall.c b/dlls/wow64/syscall.c
index fbc687cc02a2..a71945411c48 100644
--- a/dlls/wow64/syscall.c
+++ b/dlls/wow64/syscall.c
@@ -745,7 +745,7 @@ static const WCHAR *get_cpu_dll_name(void)
     {
     case IMAGE_FILE_MACHINE_I386:
         RtlInitUnicodeString( &nameW, L"\\Registry\\Machine\\Software\\Microsoft\\Wow64\\x86" );
-        ret = (native_machine == IMAGE_FILE_MACHINE_ARM64 ? L"xtajit.dll" : L"wow64cpu.dll");
+        ret = (native_machine == IMAGE_FILE_MACHINE_ARM64 ? L"libwow64fex.dll" : L"wow64cpu.dll");
         break;
     case IMAGE_FILE_MACHINE_ARMNT:
         RtlInitUnicodeString( &nameW, L"\\Registry\\Machine\\Software\\Microsoft\\Wow64\\arm" );
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 8e6956b3e9fd..551438c41b51 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -439,9 +439,9 @@ HKLM,%CurrentVersion%,"ProgramFilesDir (x86)",,"%16426%"
 HKLM,%CurrentVersion%,"CommonFilesDir (x86)",,"%16428%"
 HKLM,%CurrentVersion%,"ProgramFilesDir (Arm)",,"C:\Program Files (Arm)"
 HKLM,%CurrentVersion%,"CommonFilesDir (Arm)",,"C:\Program Files (Arm)\Common Files"
-HKLM,Software\Microsoft\Wow64\amd64,,2,"xtajit64.dll"
+HKLM,Software\Microsoft\Wow64\amd64,,2,"libarm64ecfex.dll"
 HKLM,Software\Microsoft\Wow64\arm,,2,"wowarmhw.dll"
-HKLM,Software\Microsoft\Wow64\x86,,2,"xtajit.dll"
+HKLM,Software\Microsoft\Wow64\x86,,2,"libwow64fex.dll"
 
 [CurrentVersionWow64.ntx86]
 HKLM,%CurrentVersion%,"ProgramFilesDir (x86)",,"%16422%"

From 54ec1d0127f1b05515927ef1468caa91d28829e4 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Tue, 1 Oct 2024 14:34:37 +0000
Subject: [PATCH 10/25] Avoid MS-style inline ASM on i386 clang.

---
 dlls/dinput/dinput.c    | 4 ++--
 dlls/riched20/txthost.c | 6 +++---
 dlls/riched20/txtsrv.c  | 6 +++---
 3 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/dlls/dinput/dinput.c b/dlls/dinput/dinput.c
index f851e17a2448..0b65f667cc77 100644
--- a/dlls/dinput/dinput.c
+++ b/dlls/dinput/dinput.c
@@ -45,7 +45,7 @@ static inline struct dinput *impl_from_IDirectInput8W( IDirectInput8W *iface )
     return CONTAINING_RECORD( iface, struct dinput, IDirectInput8W_iface );
 }
 
-#if defined __i386__ && defined _MSC_VER
+#if defined __i386__ && defined _MSC_VER && !defined __clang__
 __declspec(naked) BOOL enum_callback_wrapper(void *callback, const void *instance, void *ref)
 {
     __asm
@@ -59,7 +59,7 @@ __declspec(naked) BOOL enum_callback_wrapper(void *callback, const void *instanc
         ret
     }
 }
-#elif defined __i386__ && defined __GNUC__
+#elif defined __i386__
 extern BOOL enum_callback_wrapper(void *callback, const void *instance, void *ref);
 __ASM_GLOBAL_FUNC( enum_callback_wrapper,
     "pushl %ebp\n\t"
diff --git a/dlls/riched20/txthost.c b/dlls/riched20/txthost.c
index 8ae804377733..6afd85ea200d 100644
--- a/dlls/riched20/txthost.c
+++ b/dlls/riched20/txthost.c
@@ -623,7 +623,7 @@ HRESULT __thiscall ITextHostImpl_TxGetHorzExtent( ITextHost2 *iface, LONG *horz_
 #ifdef __ASM_USE_THISCALL_WRAPPER
 
 #define STDCALL(func) (void *) __stdcall_ ## func
-#ifdef _MSC_VER
+#if defined(_MSC_VER) && !defined(__clang__)
 #define DEFINE_STDCALL_WRAPPER(num,func,args) \
     __declspec(naked) HRESULT __stdcall_##func(void) \
     { \
@@ -633,7 +633,7 @@ HRESULT __thiscall ITextHostImpl_TxGetHorzExtent( ITextHost2 *iface, LONG *horz_
         __asm mov eax, [ecx] \
         __asm jmp dword ptr [eax + 4*num] \
     }
-#else /* _MSC_VER */
+#else /* defined(_MSC_VER) && !defined(__clang__) */
 #define DEFINE_STDCALL_WRAPPER(num,func,args) \
    extern HRESULT __stdcall_ ## func(void); \
    __ASM_GLOBAL_FUNC(__stdcall_ ## func, \
@@ -642,7 +642,7 @@ HRESULT __thiscall ITextHostImpl_TxGetHorzExtent( ITextHost2 *iface, LONG *horz_
                    "pushl %eax\n\t" \
                    "movl (%ecx), %eax\n\t" \
                    "jmp *(4*(" #num "))(%eax)" )
-#endif /* _MSC_VER */
+#endif /* defined(_MSC_VER) && !defined(__clang__) */
 
 DEFINE_STDCALL_WRAPPER(3,ITextHostImpl_TxGetDC,4)
 DEFINE_STDCALL_WRAPPER(4,ITextHostImpl_TxReleaseDC,8)
diff --git a/dlls/riched20/txtsrv.c b/dlls/riched20/txtsrv.c
index 5c63b3daf9af..ef1189c9a8ad 100644
--- a/dlls/riched20/txtsrv.c
+++ b/dlls/riched20/txtsrv.c
@@ -483,7 +483,7 @@ HRESULT __thiscall fnTextSrv_TxGetCachedSize(ITextServices *iface, DWORD *pdwWid
 #ifdef __ASM_USE_THISCALL_WRAPPER
 
 #define STDCALL(func) (void *) __stdcall_ ## func
-#ifdef _MSC_VER
+#if defined(_MSC_VER) && !defined(__clang__)
 #define DEFINE_STDCALL_WRAPPER(num,func) \
     __declspec(naked) HRESULT __stdcall_##func(void) \
     { \
@@ -493,7 +493,7 @@ HRESULT __thiscall fnTextSrv_TxGetCachedSize(ITextServices *iface, DWORD *pdwWid
         __asm mov eax, [ecx] \
         __asm jmp dword ptr [eax + 4*num] \
     }
-#else /* _MSC_VER */
+#else /* defined(_MSC_VER) && !defined(__clang__) */
 #define DEFINE_STDCALL_WRAPPER(num,func) \
    extern HRESULT __stdcall_ ## func(void); \
    __ASM_GLOBAL_FUNC(__stdcall_ ## func, \
@@ -502,7 +502,7 @@ HRESULT __thiscall fnTextSrv_TxGetCachedSize(ITextServices *iface, DWORD *pdwWid
                    "pushl %eax\n\t" \
                    "movl (%ecx), %eax\n\t" \
                    "jmp *(4*(" #num "))(%eax)" )
-#endif /* _MSC_VER */
+#endif /* defined(_MSC_VER) && !defined(__clang__) */
 
 DEFINE_STDCALL_WRAPPER(3, ITextServices_TxSendMessage)
 DEFINE_STDCALL_WRAPPER(4, ITextServices_TxDraw)

From 70689327d441620bfc833ad4a219e38835b1279c Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Wed, 21 Aug 2024 22:27:49 +0000
Subject: [PATCH 11/25] ntdll: Setup the FEX SVE predicate reg after handling
 signals.

No WOA devices ship with SVE, so implementing this correctly by
preserving the SVE state in xstate isn't really viable for now so just
hardcode the FEX values.
---
 dlls/ntdll/unix/signal_arm64.c | 28 ++++++++++++++++++++++++++--
 1 file changed, 26 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/signal_arm64.c b/dlls/ntdll/unix/signal_arm64.c
index 9964d0a92242..2871a86b1071 100644
--- a/dlls/ntdll/unix/signal_arm64.c
+++ b/dlls/ntdll/unix/signal_arm64.c
@@ -84,10 +84,20 @@ WINE_DEFAULT_DEBUG_CHANNEL(seh);
 static struct _aarch64_ctx *get_extended_sigcontext( const ucontext_t *sigcontext, unsigned int magic )
 {
     struct _aarch64_ctx *ctx = (struct _aarch64_ctx *)sigcontext->uc_mcontext.__reserved;
-    while ((char *)ctx < (char *)(&sigcontext->uc_mcontext + 1) && ctx->magic && ctx->size)
+    BOOL extra = FALSE;
+    while ((extra || (char *)ctx < (char *)(&sigcontext->uc_mcontext + 1)) && ctx->magic && ctx->size)
     {
         if (ctx->magic == magic) return ctx;
-        ctx = (struct _aarch64_ctx *)((char *)ctx + ctx->size);
+
+        if (ctx->magic == EXTRA_MAGIC)
+        {
+            ctx = (struct _aarch64_ctx *)((struct extra_context *)ctx)->datap;
+            extra = TRUE;
+        }
+        else
+        {
+            ctx = (struct _aarch64_ctx *)((char *)ctx + ctx->size);
+        }
     }
     return NULL;
 }
@@ -97,6 +107,11 @@ static struct fpsimd_context *get_fpsimd_context( const ucontext_t *sigcontext )
     return (struct fpsimd_context *)get_extended_sigcontext( sigcontext, FPSIMD_MAGIC );
 }
 
+static struct sve_context *get_sve_context( const ucontext_t *sigcontext )
+{
+    return (struct sve_context *)get_extended_sigcontext( sigcontext, SVE_MAGIC );
+}
+
 static DWORD64 get_fault_esr( ucontext_t *sigcontext )
 {
     struct esr_context *esr = (struct esr_context *)get_extended_sigcontext( sigcontext, ESR_MAGIC );
@@ -1332,12 +1347,21 @@ static void usr2_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 #ifdef linux
     {
         struct fpsimd_context *fp = get_fpsimd_context( sigcontext );
+        struct sve_context *sve = get_sve_context( sigcontext );
         if (fp)
         {
             fp->fpcr = frame->fpcr;
             fp->fpsr = frame->fpsr;
             memcpy( fp->vregs, frame->v, sizeof(fp->vregs) );
         }
+
+        if (sve)
+        {
+            /* setup FEX SVE state */
+            ULONG64 vq = sve_vq_from_vl(sve->vl);
+            *(UINT16 *)((BYTE *)sve + SVE_SIG_PREG_OFFSET(vq, 2)) = 0x155;
+            *(UINT16 *)((BYTE *)sve + SVE_SIG_PREG_OFFSET(vq, 6)) = 0xffff;
+        }
     }
 #elif defined(__APPLE__)
     context->uc_mcontext->__ns.__fpcr = frame->fpcr;

From 6149dd84d8045b7d4ec8b66bc00dc63a455014a1 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Thu, 23 Jan 2025 01:04:14 +0000
Subject: [PATCH 12/25] ntdll: Add an interface to map the FEX stats shm.

---
 dlls/ntdll/unix/virtual.c | 53 +++++++++++++++++++++++++++++++++++++++
 include/winternl.h        |  7 ++++++
 2 files changed, 60 insertions(+)

diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index cb060605205c..7f3f4f59b7ac 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -241,6 +241,9 @@ static void *preload_reserve_end;
 static BOOL force_exec_prot;  /* whether to force PROT_EXEC on all PROT_READ mmaps */
 static BOOL enable_write_exceptions;  /* raise exception on writes to executable memory */
 
+#define FEX_STATS_SHM_MAX_SIZE 0x400000
+static void *fex_stats_shm;
+
 struct range_entry
 {
     void *base;
@@ -5890,6 +5893,49 @@ static unsigned int get_memory_image_info( HANDLE process, LPCVOID addr, MEMORY_
     return status;
 }
 
+#if defined(linux) && defined(__aarch64__)
+NTSTATUS get_memory_fex_stats_shm( HANDLE process, LPCVOID addr, MEMORY_FEX_STATS_SHM_INFORMATION *info,
+                                   SIZE_T len, SIZE_T *res_len)
+{
+    char buf[0x20];
+    int fd;
+    int oflag = O_RDWR;
+
+    if (len != sizeof(*info)) return STATUS_INFO_LENGTH_MISMATCH;
+    if (process != GetCurrentProcess()) return STATUS_INVALID_HANDLE;
+
+    sprintf( buf, "fex-%d-stats", getpid() );
+
+    if (!fex_stats_shm) {
+        fex_stats_shm = mmap( NULL, FEX_STATS_SHM_MAX_SIZE, PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS |
+                              MAP_NORESERVE, -1, 0 );
+        if (fex_stats_shm == MAP_FAILED) {
+            fex_stats_shm = NULL;
+            return STATUS_INTERNAL_ERROR;
+        }
+
+        oflag |= O_CREAT | O_TRUNC;
+    }
+
+    fd = shm_open( buf, oflag, S_IRWXU | S_IRWXG | S_IRWXO );
+    if (fd == -1) return STATUS_INTERNAL_ERROR;
+
+    if (ftruncate( fd, info->map_size )) goto err;
+
+    if (mmap( fex_stats_shm, info->map_size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, fd,
+              0 ) == MAP_FAILED) goto err;
+
+    close( fd );
+
+    info->shm_base = fex_stats_shm;
+    *res_len = len;
+    return STATUS_SUCCESS;
+
+err:
+    close( fd );
+    return STATUS_INTERNAL_ERROR;
+}
+#endif
 
 /***********************************************************************
  *             NtQueryVirtualMemory   (NTDLL.@)
@@ -5935,6 +5981,13 @@ NTSTATUS WINAPI NtQueryVirtualMemory( HANDLE process, LPCVOID addr,
             }
             return STATUS_INVALID_HANDLE;
 
+        case MemoryFexStatsShm:
+#if defined(linux) && defined(__aarch64__)
+            return get_memory_fex_stats_shm( process, addr, buffer, len, res_len );
+#else
+            FIXME("MemoryFexStatsShm unsupported\n");
+            break;
+#endif
         default:
             FIXME("(%p,%p,info_class=%d,%p,%ld,%p) Unknown information class\n",
                   process, addr, info_class, buffer, len, res_len);
diff --git a/include/winternl.h b/include/winternl.h
index 9bc5d0dac033..5cdb435c11a2 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -2313,6 +2313,7 @@ typedef enum _MEMORY_INFORMATION_CLASS {
     MemoryWineUnixFuncs = 1000,
     MemoryWineUnixWow64Funcs,
 #endif
+    MemoryFexStatsShm = 2000,
 } MEMORY_INFORMATION_CLASS;
 
 typedef struct _MEMORY_SECTION_NAME
@@ -2379,6 +2380,12 @@ typedef struct _MEMORY_IMAGE_INFORMATION
     };
 } MEMORY_IMAGE_INFORMATION, *PMEMORY_IMAGE_INFORMATION;
 
+typedef struct _MEMORY_FEX_STATS_SHM_INFORMATION
+{
+    void *shm_base;
+    SIZE_T map_size;
+} MEMORY_FEX_STATS_SHM_INFORMATION, *PMEMORY_FEX_STATS_SHM_INFORMATION;
+
 typedef enum _MUTANT_INFORMATION_CLASS
 {
     MutantBasicInformation

From c1da8b90ea41bda32676f73f32cd272a45e4b534 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Thu, 10 Jul 2025 16:09:08 +0100
Subject: [PATCH 13/25] ntdll: Add FEX specific Asahi TSO support

---
 dlls/ntdll/unix/process.c | 36 ++++++++++++++++++++++++++++++++++++
 include/winternl.h        |  1 +
 2 files changed, 37 insertions(+)

diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index 727b6dd9380b..1ff4fb2fcb85 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -46,6 +46,9 @@
 #ifdef HAVE_SYS_PARAM_H
 # include <sys/param.h>
 #endif
+#ifdef HAVE_SYS_PRCTL_H
+# include <sys/prctl.h>
+#endif
 #ifdef HAVE_SYS_QUEUE_H
 # include <sys/queue.h>
 #endif
@@ -1092,6 +1095,35 @@ void fill_vm_counters( VM_COUNTERS_EX *pvmi, int unix_pid )
 
 #endif
 
+static BOOL set_hardware_tso( BOOL enable ) {
+#ifdef HAVE_PRCTL
+#ifndef PR_GET_MEM_MODEL
+#define PR_GET_MEM_MODEL 0x6d4d444c
+#endif
+#ifndef PR_SET_MEM_MODEL
+#define PR_SET_MEM_MODEL 0x4d4d444c
+#endif
+#ifndef PR_SET_MEM_MODEL_DEFAULT
+#define PR_SET_MEM_MODEL_DEFAULT 0
+#endif
+#ifndef PR_SET_MEM_MODEL_TSO
+#define PR_SET_MEM_MODEL_TSO 1
+#endif
+    if (enable)
+    {
+        int ret = prctl( PR_GET_MEM_MODEL, 0, 0, 0, 0 );
+        if (ret == PR_SET_MEM_MODEL_DEFAULT)
+            return !prctl( PR_SET_MEM_MODEL, PR_SET_MEM_MODEL_TSO, 0, 0, 0 );
+        return ret == PR_SET_MEM_MODEL_TSO;
+    }
+
+    prctl( PR_SET_MEM_MODEL, PR_SET_MEM_MODEL_DEFAULT, 0, 0, 0 );
+    return TRUE;
+#else
+    return FALSE;
+#endif
+}
+
 #define UNIMPLEMENTED_INFO_CLASS(c) \
     case c: \
         FIXME( "(process=%p) Unimplemented information class: " #c "\n", handle); \
@@ -1859,6 +1891,10 @@ NTSTATUS WINAPI NtSetInformationProcess( HANDLE handle, PROCESSINFOCLASS class,
         SERVER_END_REQ;
         break;
 
+    case ProcessFexHardwareTso:
+        if (size != sizeof(BOOL)) return STATUS_INFO_LENGTH_MISMATCH;
+        return set_hardware_tso( *(BOOL *)info ) ? STATUS_SUCCESS : STATUS_NOT_SUPPORTED;
+
     case ProcessPowerThrottlingState:
         FIXME( "ProcessPowerThrottlingState - stub\n" );
         return STATUS_SUCCESS;
diff --git a/include/winternl.h b/include/winternl.h
index 5cdb435c11a2..12898d4f7357 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -1910,6 +1910,7 @@ typedef enum _PROCESSINFOCLASS {
     ProcessWineLdtCopy,
     ProcessWineGrantAdminToken,
 #endif
+    ProcessFexHardwareTso = 2000,
 } PROCESSINFOCLASS;
 
 #define MEM_EXECUTE_OPTION_DISABLE   0x01

From 7dde31169d16084b8dc3c0f11cc2be1df408bfa3 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Thu, 10 Jul 2025 18:55:42 +0100
Subject: [PATCH 14/25] HACK: ntdll: Manually define exit thunks for
 mem{cpy/move/set}

---
 dlls/winecrt0/arm64ec.c | 41 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 41 insertions(+)

diff --git a/dlls/winecrt0/arm64ec.c b/dlls/winecrt0/arm64ec.c
index a3af06b380d4..a8c82facbdab 100644
--- a/dlls/winecrt0/arm64ec.c
+++ b/dlls/winecrt0/arm64ec.c
@@ -103,4 +103,45 @@ asm( "\t.section .rdata,\"dr\"\n"
      "\t.rva __os_arm64x_helper7\n"
      "\t.rva __os_arm64x_helper8\n" );
 
+/*
+ * HACK: Provide an exit thunk for memcpy/memmove/memset to work around
+ * https://github.com/llvm/llvm-project/issues/101355
+ */
+asm( "\t.def $iexit_thunk$cdecl$i8$i8i8i8; .scl 2; .type 32; .endef\n"
+     "\t.section .wowthk$aa,\"xr\",discard,$iexit_thunk$cdecl$i8$i8i8i8\n"
+     "\t.globl  $iexit_thunk$cdecl$i8$i8i8i8\n"
+     "\t.p2align 2\n"
+     "$iexit_thunk$cdecl$i8$i8i8i8:\n"
+     "\t.seh_proc $iexit_thunk$cdecl$i8$i8i8i8\n"
+     "\tsub     sp, sp, #48\n"
+     "\t.seh_stackalloc 48\n"
+     "\tstp     x29, x30, [sp, #32]\n"
+     "\t.seh_save_fplr 32\n"
+     "\tadd     x29, sp, #32\n"
+     "\t.seh_add_fp 32\n"
+     "\t.seh_endprologue\n"
+     "\tadrp    x8, __os_arm64x_dispatch_call_no_redirect\n"
+     "\tldr     x16, [x8, :lo12:__os_arm64x_dispatch_call_no_redirect]\n"
+     "\tblr     x16\n"
+     "\tmov     x0, x8\n"
+     "\t.seh_startepilogue\n"
+     "\tldp     x29, x30, [sp, #32]\n"
+     "\t.seh_save_fplr  32\n"
+     "\tadd     sp, sp, #48\n"
+     "\t.seh_stackalloc 48\n"
+     "\t.seh_endepilogue\n"
+     "\tret\n"
+     "\t.seh_endproc\n"
+
+     "\t.section .hybmp$x,\"yi\"\n"
+     "\t.symidx memcpy\n"
+     "\t.symidx $iexit_thunk$cdecl$i8$i8i8i8\n"
+     "\t.word 4\n"
+     "\t.symidx memmove\n"
+     "\t.symidx $iexit_thunk$cdecl$i8$i8i8i8\n"
+     "\t.word 4\n"
+     "\t.symidx memset\n"
+     "\t.symidx $iexit_thunk$cdecl$i8$i8i8i8\n"
+     "\t.word 4\n" );
+
 #endif /* __arm64ec__ */

From 745f06029c76c0238207dbe2eaf14084528196c1 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Tue, 15 Jul 2025 17:09:15 +0100
Subject: [PATCH 15/25] HACK: Avoid delay importing rpcrt4

Works around broken variadic exit thunks.
---
 dlls/advapi32/Makefile.in | 4 ++--
 dlls/sechost/Makefile.in  | 3 +--
 2 files changed, 3 insertions(+), 4 deletions(-)

diff --git a/dlls/advapi32/Makefile.in b/dlls/advapi32/Makefile.in
index 57bb25feb9c6..671cb02fcd0c 100644
--- a/dlls/advapi32/Makefile.in
+++ b/dlls/advapi32/Makefile.in
@@ -1,8 +1,8 @@
 EXTRADEFS = -D_ADVAPI32_
 MODULE    = advapi32.dll
 IMPORTLIB = advapi32
-IMPORTS   = kernelbase sechost msvcrt
-DELAYIMPORTS = cryptsp rpcrt4 user32 userenv
+IMPORTS   = kernelbase sechost msvcrt rpcrt4
+DELAYIMPORTS = cryptsp user32 userenv
 
 SOURCES = \
 	advapi.c \
diff --git a/dlls/sechost/Makefile.in b/dlls/sechost/Makefile.in
index ec1eb100683c..25439e94090f 100644
--- a/dlls/sechost/Makefile.in
+++ b/dlls/sechost/Makefile.in
@@ -1,7 +1,6 @@
 MODULE    = sechost.dll
 IMPORTLIB = sechost
-IMPORTS   = kernelbase
-DELAYIMPORTS = rpcrt4
+IMPORTS   = kernelbase rpcrt4
 
 SOURCES = \
 	plugplay.idl \

From ae9514d0c07c6ba80518b2d3789f450ccf605f1e Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Wed, 6 Aug 2025 21:56:24 +0100
Subject: [PATCH 16/25] ntdll: Implement FEX-specific kernel-side unaligned
 atomic handling.

---
 dlls/ntdll/unix/process.c | 15 +++++++++++++++
 include/winternl.h        |  6 ++++++
 2 files changed, 21 insertions(+)

diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index 1ff4fb2fcb85..06af5b780bf8 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -1124,6 +1124,17 @@ static BOOL set_hardware_tso( BOOL enable ) {
 #endif
 }
 
+static BOOL set_unalign_atomic_mode( ULONG64 flags ) {
+#ifdef HAVE_PRCTL
+#ifndef PR_ARM64_SET_UNALIGN_ATOMIC
+#define PR_ARM64_SET_UNALIGN_ATOMIC 0x46455849
+#endif
+    return !prctl( PR_ARM64_SET_UNALIGN_ATOMIC, flags, 0, 0, 0 );;
+#else
+    return FALSE;
+#endif
+}
+
 #define UNIMPLEMENTED_INFO_CLASS(c) \
     case c: \
         FIXME( "(process=%p) Unimplemented information class: " #c "\n", handle); \
@@ -1895,6 +1906,10 @@ NTSTATUS WINAPI NtSetInformationProcess( HANDLE handle, PROCESSINFOCLASS class,
         if (size != sizeof(BOOL)) return STATUS_INFO_LENGTH_MISMATCH;
         return set_hardware_tso( *(BOOL *)info ) ? STATUS_SUCCESS : STATUS_NOT_SUPPORTED;
 
+    case ProcessFexUnalignAtomic:
+        if (size != sizeof(ULONG64)) return STATUS_INFO_LENGTH_MISMATCH;
+        return set_unalign_atomic_mode( *(ULONG64 *)info ) ? STATUS_SUCCESS : STATUS_NOT_SUPPORTED;
+
     case ProcessPowerThrottlingState:
         FIXME( "ProcessPowerThrottlingState - stub\n" );
         return STATUS_SUCCESS;
diff --git a/include/winternl.h b/include/winternl.h
index 12898d4f7357..d710fd383b8f 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -1911,8 +1911,14 @@ typedef enum _PROCESSINFOCLASS {
     ProcessWineGrantAdminToken,
 #endif
     ProcessFexHardwareTso = 2000,
+    ProcessFexUnalignAtomic,
 } PROCESSINFOCLASS;
 
+// These match the prctl flag values
+#define FEX_UNALIGN_ATOMIC_EMULATE       (1ULL << 0)
+#define FEX_UNALIGN_ATOMIC_BACKPATCH     (1ULL << 1)
+#define FEX_UNALIGN_ATOMIC_STRICT_SPLIT_LOCKS    (1ULL << 2)
+
 #define MEM_EXECUTE_OPTION_DISABLE   0x01
 #define MEM_EXECUTE_OPTION_ENABLE    0x02
 #define MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION 0x04

From fb3f9cdea5d8e4e5a8f358e51d0af9d3b53dc3e5 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Thu, 7 Aug 2025 20:57:03 +0100
Subject: [PATCH 17/25] WIP: ntdll: ARM64EC suspend support

---
 dlls/ntdll/unix/signal_arm64.c | 57 ++++++++++++++++++++++++++++++----
 1 file changed, 51 insertions(+), 6 deletions(-)

diff --git a/dlls/ntdll/unix/signal_arm64.c b/dlls/ntdll/unix/signal_arm64.c
index 2871a86b1071..4005aadcc66b 100644
--- a/dlls/ntdll/unix/signal_arm64.c
+++ b/dlls/ntdll/unix/signal_arm64.c
@@ -65,6 +65,18 @@ WINE_DEFAULT_DEBUG_CHANNEL(seh);
 #define NTDLL_DWARF_H_NO_UNWINDER
 #include "dwarf.h"
 
+struct arm64_thread_data
+{
+    BOOL suspend_pending;
+};
+
+C_ASSERT( sizeof(struct arm64_thread_data) <= sizeof(((struct ntdll_thread_data *)0)->cpu_data) );
+
+static inline struct arm64_thread_data *arm64_thread_data(void)
+{
+    return (struct arm64_thread_data *)ntdll_get_thread_data()->cpu_data;
+}
+
 /***********************************************************************
  * signal context platform-specific definitions
  */
@@ -201,6 +213,10 @@ struct syscall_frame
 
 C_ASSERT( sizeof( struct syscall_frame ) == 0x330 );
 
+static BOOL is_arm64ec_suspend_doorbell_valid(void)
+{
+    return is_arm64ec() && NtCurrentTeb()->ChpeV2CpuAreaInfo && NtCurrentTeb()->ChpeV2CpuAreaInfo->SuspendDoorbell;
+}
 
 /***********************************************************************
  *           context_init_empty_xstate
@@ -225,7 +241,6 @@ void set_process_instrumentation_callback( void *callback )
     if (callback) FIXME( "Not supported.\n" );
 }
 
-
 /***********************************************************************
  *           syscall_frame_fixup_for_fastpath
  *
@@ -334,7 +349,18 @@ NTSTATUS signal_set_full_context( CONTEXT *context )
     struct syscall_frame *frame = get_syscall_frame();
     NTSTATUS status = NtSetContextThread( GetCurrentThread(), context );
 
-    if (!status && (context->ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER)
+    if (is_arm64ec_suspend_doorbell_valid() && arm64_thread_data()->suspend_pending)
+    {
+        CONTEXT suspend_context;
+        *NtCurrentTeb()->ChpeV2CpuAreaInfo->SuspendDoorbell = 0;
+        arm64_thread_data()->suspend_pending = FALSE;
+        suspend_context.ContextFlags = CONTEXT_FULL | CONTEXT_EXCEPTION_REPORTING; /* TODO: check */
+        NtGetContextThread( GetCurrentThread(), &suspend_context );
+        wait_suspend( &suspend_context );
+        NtSetContextThread( GetCurrentThread(), &suspend_context );
+    }
+
+    if (!status && (context->ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) /* TODO: also check with susp */
         frame->restore_flags |= CONTEXT_INTEGER;
 
     if (is_arm64ec() && !is_ec_code( frame->pc ))
@@ -425,12 +451,20 @@ NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
 {
     struct syscall_frame *frame = get_syscall_frame();
     DWORD needed_flags = context->ContextFlags & ~CONTEXT_ARM64;
-    BOOL self = (handle == GetCurrentThread());
+    THREAD_BASIC_INFORMATION info;
+    NTSTATUS ret;
+    BOOL self;
+
+    NtQueryInformationThread( handle, ThreadBasicInformation, &info, sizeof(info), NULL );
+    self = HandleToULong( info.ClientId.UniqueThread ) == GetCurrentThreadId();
 
     if (!self)
     {
-        NTSTATUS ret = get_thread_context( handle, context, &self, IMAGE_FILE_MACHINE_ARM64 );
-        if (ret || !self) return ret;
+        /* Avoid exposing JIT code pointers to other processes on ARM64EC */
+        if (is_arm64ec()) NtSuspendThread( handle, NULL );
+        ret = get_thread_context( handle, context, &self, IMAGE_FILE_MACHINE_ARM64 );
+        if (is_arm64ec()) NtResumeThread( handle, NULL );
+        return ret;
     }
 
     if (needed_flags & CONTEXT_INTEGER)
@@ -1307,6 +1341,14 @@ static void usr1_handler( int signal, siginfo_t *siginfo, void *sigcontext )
     ucontext_t *ucontext = sigcontext;
     CONTEXT context;
 
+    if (is_arm64ec_suspend_doorbell_valid() &&
+        (NtCurrentTeb()->ChpeV2CpuAreaInfo->InSimulation || NtCurrentTeb()->ChpeV2CpuAreaInfo->InSyscallCallback))
+    {
+        *NtCurrentTeb()->ChpeV2CpuAreaInfo->SuspendDoorbell = 1;
+        arm64_thread_data()->suspend_pending = TRUE;
+        return;
+    }
+
     if (is_inside_syscall( SP_sig(ucontext) ))
     {
         context.ContextFlags = CONTEXT_FULL | CONTEXT_EXCEPTION_REQUEST;
@@ -1470,11 +1512,14 @@ void syscall_dispatcher_return_slowpath(void)
  */
 void init_syscall_frame( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend, TEB *teb )
 {
-    struct syscall_frame *frame = ((struct ntdll_thread_data *)&teb->GdiTebBatch)->syscall_frame;
+    struct ntdll_thread_data *thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
+    struct syscall_frame *frame = thread_data->syscall_frame;
     CONTEXT *ctx, context = { CONTEXT_ALL };
     I386_CONTEXT *i386_context;
     ARM_CONTEXT *arm_context;
 
+    ((struct arm64_thread_data *)(thread_data->cpu_data))->suspend_pending = FALSE;
+
     context.X0  = (DWORD64)entry;
     context.X1  = (DWORD64)arg;
     context.X18 = (DWORD64)teb;

From 7602e0738646b13485352736c356656e2068c694 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Mon, 11 Aug 2025 16:24:49 +0100
Subject: [PATCH 18/25] ntdll/tests: Add
 THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE test.

---
 dlls/ntdll/tests/thread.c | 32 ++++++++++++++++++++++++++++++++
 include/winternl.h        |  5 +++--
 2 files changed, 35 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/tests/thread.c b/dlls/ntdll/tests/thread.c
index 436b1bf89e0a..0a8facc45eda 100644
--- a/dlls/ntdll/tests/thread.c
+++ b/dlls/ntdll/tests/thread.c
@@ -31,6 +31,9 @@
 static NTSTATUS (WINAPI *pNtCreateThreadEx)( HANDLE *, ACCESS_MASK, OBJECT_ATTRIBUTES *,
                                              HANDLE, PRTL_THREAD_START_ROUTINE, void *,
                                              ULONG, ULONG_PTR, SIZE_T, SIZE_T, PS_ATTRIBUTE_LIST * );
+static NTSTATUS  (WINAPI *pNtSuspendProcess)(HANDLE process);
+static NTSTATUS  (WINAPI *pNtResumeProcess)(HANDLE process);
+
 static int * (CDECL *p_errno)(void);
 
 static void init_function_pointers(void)
@@ -38,6 +41,8 @@ static void init_function_pointers(void)
     HMODULE hntdll = GetModuleHandleA( "ntdll.dll" );
 #define GET_FUNC(name) p##name = (void *)GetProcAddress( hntdll, #name );
     GET_FUNC( NtCreateThreadEx );
+    GET_FUNC( NtSuspendProcess );
+    GET_FUNC( NtResumeProcess );
     GET_FUNC( _errno );
 #undef GET_FUNC
 }
@@ -242,6 +247,32 @@ static void test_NtCreateUserProcess(void)
     CloseHandle( thread );
 }
 
+static void CALLBACK test_thread_bypass_process_freeze_proc(void *param)
+{
+    pNtSuspendProcess(NtCurrentProcess());
+    /* The current process will be suspended forever here if THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE is nonfunctional. */
+    pNtResumeProcess(NtCurrentProcess());
+}
+
+static void test_thread_bypass_process_freeze(void)
+{
+    HANDLE thread;
+    NTSTATUS status;
+
+    if (!pNtCreateThreadEx || !pNtSuspendProcess || !pNtResumeProcess)
+    {
+        win_skip( "NtCreateThreadEx/NtSuspendProcess/NtResumeProcess are not available.\n" );
+        return;
+    }
+
+    status = pNtCreateThreadEx( &thread, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(), test_thread_bypass_process_freeze_proc,
+                                NULL, THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE, 0, 0, 0, NULL );
+    todo_wine ok( status == STATUS_SUCCESS, "Got unexpected status %#lx.\n", status );
+
+    WaitForSingleObject( thread, INFINITE );
+    CloseHandle( thread );
+}
+
 START_TEST(thread)
 {
     init_function_pointers();
@@ -250,4 +281,5 @@ START_TEST(thread)
     test_unique_teb();
     test_errno();
     test_NtCreateUserProcess();
+    test_thread_bypass_process_freeze();
 }
diff --git a/include/winternl.h b/include/winternl.h
index d710fd383b8f..c966f4c88e58 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -3950,8 +3950,9 @@ typedef struct _RTL_PROCESS_MODULE_INFORMATION_EX
 #define THREAD_CREATE_FLAGS_CREATE_SUSPENDED        0x00000001
 #define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH      0x00000002
 #define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER      0x00000004
-#define THREAD_CREATE_FLAGS_HAS_SECURITY_DESCRIPTOR 0x00000010
-#define THREAD_CREATE_FLAGS_ACCESS_CHECK_IN_TARGET  0x00000020
+#define THREAD_CREATE_FLAGS_LOADER_WORKER           0x00000010
+#define THREAD_CREATE_FLAGS_SKIP_LOADER_INIT        0x00000020
+#define THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE   0x00000040
 #define THREAD_CREATE_FLAGS_INITIAL_THREAD          0x00000080
 
 #ifdef __WINESRC__

From 8ae00fc2e84d35d278a96432292d3ff1eca84666 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Mon, 11 Aug 2025 16:28:42 +0100
Subject: [PATCH 19/25] ntdll: Support
 THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE flag.

---
 dlls/ntdll/tests/thread.c |  2 +-
 dlls/ntdll/unix/thread.c  |  3 ++-
 server/process.c          |  8 ++++----
 server/thread.c           | 21 ++++++++++++++-------
 server/thread.h           |  1 +
 5 files changed, 22 insertions(+), 13 deletions(-)

diff --git a/dlls/ntdll/tests/thread.c b/dlls/ntdll/tests/thread.c
index 0a8facc45eda..30b24007c7a7 100644
--- a/dlls/ntdll/tests/thread.c
+++ b/dlls/ntdll/tests/thread.c
@@ -267,7 +267,7 @@ static void test_thread_bypass_process_freeze(void)
 
     status = pNtCreateThreadEx( &thread, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(), test_thread_bypass_process_freeze_proc,
                                 NULL, THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE, 0, 0, 0, NULL );
-    todo_wine ok( status == STATUS_SUCCESS, "Got unexpected status %#lx.\n", status );
+    ok( status == STATUS_SUCCESS, "Got unexpected status %#lx.\n", status );
 
     WaitForSingleObject( thread, INFINITE );
     CloseHandle( thread );
diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index ce6683e075f0..02d96c1a6fcd 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -1315,7 +1315,8 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE *handle, ACCESS_MASK access, OBJECT_ATT
                                   ULONG flags, ULONG_PTR zero_bits, SIZE_T stack_commit,
                                   SIZE_T stack_reserve, PS_ATTRIBUTE_LIST *attr_list )
 {
-    static const ULONG supported_flags = THREAD_CREATE_FLAGS_CREATE_SUSPENDED | THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER;
+    static const ULONG supported_flags = THREAD_CREATE_FLAGS_CREATE_SUSPENDED | THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER |
+                                         THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE;
     sigset_t sigset;
     pthread_t pthread_id;
     pthread_attr_t pthread_attr;
diff --git a/server/process.c b/server/process.c
index 9b3b0b8fc6cd..fc4850b36f99 100644
--- a/server/process.c
+++ b/server/process.c
@@ -1053,7 +1053,7 @@ void suspend_process( struct process *process )
         LIST_FOR_EACH_SAFE( ptr, next, &process->thread_list )
         {
             struct thread *thread = LIST_ENTRY( ptr, struct thread, proc_entry );
-            if (!thread->suspend) stop_thread( thread );
+            if (!thread->bypass_proc_suspend && !thread->suspend) stop_thread( thread );
         }
     }
 }
@@ -1069,7 +1069,7 @@ void resume_process( struct process *process )
         LIST_FOR_EACH_SAFE( ptr, next, &process->thread_list )
         {
             struct thread *thread = LIST_ENTRY( ptr, struct thread, proc_entry );
-            if (!thread->suspend) wake_thread( thread );
+            if (!thread->bypass_proc_suspend && !thread->suspend) wake_thread( thread );
         }
     }
 }
@@ -2005,7 +2005,7 @@ DECL_HANDLER(suspend_process)
         LIST_FOR_EACH_SAFE( ptr, next, &process->thread_list )
         {
             struct thread *thread = LIST_ENTRY( ptr, struct thread, proc_entry );
-            suspend_thread( thread );
+            if (!thread->bypass_proc_suspend) suspend_thread( thread );
         }
 
         release_object( process );
@@ -2024,7 +2024,7 @@ DECL_HANDLER(resume_process)
         LIST_FOR_EACH_SAFE( ptr, next, &process->thread_list )
         {
             struct thread *thread = LIST_ENTRY( ptr, struct thread, proc_entry );
-            resume_thread( thread );
+            if (!thread->bypass_proc_suspend) resume_thread( thread );
         }
 
         release_object( process );
diff --git a/server/thread.c b/server/thread.c
index 05ec6a4ec002..46b126c0a5b0 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -418,6 +418,7 @@ static inline void init_thread_structure( struct thread *thread )
     thread->base_priority   = 0;
     thread->suspend         = 0;
     thread->dbg_hidden      = 0;
+    thread->bypass_proc_suspend = 0;
     thread->desktop_users   = 0;
     thread->token           = NULL;
     thread->desc            = NULL;
@@ -436,6 +437,11 @@ static inline void init_thread_structure( struct thread *thread )
         thread->inflight[i].server = thread->inflight[i].client = -1;
 }
 
+static int get_effective_proc_suspend( struct thread *thread )
+{
+    return thread->bypass_proc_suspend ? 0 : thread->process->suspend;
+}
+
 /* check if address looks valid for a client-side data structure (TEB etc.) */
 static inline int is_valid_address( client_ptr_t addr )
 {
@@ -927,7 +933,7 @@ int suspend_thread( struct thread *thread )
     int old_count = thread->suspend;
     if (thread->suspend < MAXIMUM_SUSPEND_COUNT)
     {
-        if (!(thread->process->suspend + thread->suspend++)) stop_thread( thread );
+        if (!(get_effective_proc_suspend( thread ) + thread->suspend++)) stop_thread( thread );
     }
     else set_error( STATUS_SUSPEND_COUNT_EXCEEDED );
     return old_count;
@@ -940,7 +946,7 @@ int resume_thread( struct thread *thread )
     if (thread->suspend > 0)
     {
         if (!(--thread->suspend)) resume_delayed_debug_events( thread );
-        if (!(thread->suspend + thread->process->suspend)) wake_thread( thread );
+        if (!(thread->suspend + get_effective_proc_suspend( thread ))) wake_thread( thread );
     }
     return old_count;
 }
@@ -1121,7 +1127,7 @@ static int check_wait( struct thread *thread )
         return STATUS_KERNEL_APC;
 
     /* Suspended threads may not acquire locks, but they can run system APCs */
-    if (thread->process->suspend + thread->suspend > 0) return -1;
+    if (get_effective_proc_suspend( thread ) + thread->suspend > 0) return -1;
 
     if (wait->select == SELECT_WAIT_ALL)
     {
@@ -1208,7 +1214,7 @@ int wake_thread_queue_entry( struct wait_queue_entry *entry )
     client_ptr_t cookie;
 
     if (thread->wait != wait) return 0;  /* not the current wait */
-    if (thread->process->suspend + thread->suspend > 0) return 0;  /* cannot acquire locks */
+    if (get_effective_proc_suspend( thread ) + thread->suspend > 0) return 0;  /* cannot acquire locks */
 
     assert( wait->select != SELECT_WAIT_ALL );
 
@@ -1231,7 +1237,7 @@ static void thread_timeout( void *ptr )
 
     wait->user = NULL;
     if (thread->wait != wait) return; /* not the top-level wait, ignore it */
-    if (thread->suspend + thread->process->suspend > 0) return;  /* suspended, ignore it */
+    if (thread->suspend + get_effective_proc_suspend( thread ) > 0) return;  /* suspended, ignore it */
 
     if (debug_level) fprintf( stderr, "%04x: *wakeup* signaled=TIMEOUT\n", thread->id );
     end_wait( thread, STATUS_TIMEOUT );
@@ -1369,7 +1375,7 @@ static inline struct list *get_apc_queue( struct thread *thread, enum apc_type t
 /* check if thread is currently waiting for a (system) apc */
 static inline int is_in_apc_wait( struct thread *thread )
 {
-    return (thread->process->suspend || thread->suspend ||
+    return (get_effective_proc_suspend( thread ) || thread->suspend ||
             (thread->wait && (thread->wait->flags & SELECT_INTERRUPTIBLE)));
 }
 
@@ -1646,6 +1652,7 @@ DECL_HANDLER(new_thread)
         thread->system_regs = current->system_regs;
         if (req->flags & THREAD_CREATE_FLAGS_CREATE_SUSPENDED) thread->suspend++;
         thread->dbg_hidden = !!(req->flags & THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER);
+        thread->bypass_proc_suspend = !!(req->flags & THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE);
         reply->tid = get_thread_id( thread );
         if ((reply->handle = alloc_handle_no_access_check( current->process, thread,
                                                            req->access, objattr->attributes )))
@@ -1739,7 +1746,7 @@ DECL_HANDLER(init_thread)
     set_thread_base_priority( current, current->base_priority );
     set_thread_affinity( current, current->affinity );
 
-    reply->suspend = (current->suspend || current->process->suspend || current->context != NULL);
+    reply->suspend = (current->suspend || get_effective_proc_suspend( current ) || current->context != NULL);
 }
 
 /* terminate a thread */
diff --git a/server/thread.h b/server/thread.h
index 58081be74811..2a144c2b2484 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -86,6 +86,7 @@ struct thread
     int                    base_priority; /* base priority level (relative to process base priority class) */
     int                    suspend;       /* suspend count */
     int                    dbg_hidden;    /* hidden from debugger */
+    int                    bypass_proc_suspend; /* will still run if the process is suspended */
     obj_handle_t           desktop;       /* desktop handle */
     int                    desktop_users; /* number of objects using the thread desktop */
     timeout_t              creation_time; /* Thread creation time */

From 752d0a947123d0ddcb51e769771adec344e2709d Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Mon, 11 Aug 2025 16:35:17 +0100
Subject: [PATCH 20/25] ntdll/tests: Add THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH
 test.

---
 dlls/ntdll/tests/Makefile.in |   2 +
 dlls/ntdll/tests/thread.c    | 124 +++++++++++++++++++++++++++++++++++
 include/winternl.h           |  66 ++++++++++++++++++-
 3 files changed, 189 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/tests/Makefile.in b/dlls/ntdll/tests/Makefile.in
index 3742968c4159..04657aee627a 100644
--- a/dlls/ntdll/tests/Makefile.in
+++ b/dlls/ntdll/tests/Makefile.in
@@ -23,6 +23,8 @@ SOURCES = \
 	string.c \
 	sync.c \
 	thread.c \
+	testdll.c \
+	testdll.spec \
 	threadpool.c \
 	time.c \
 	unwind.c \
diff --git a/dlls/ntdll/tests/thread.c b/dlls/ntdll/tests/thread.c
index 30b24007c7a7..1988dcd95d82 100644
--- a/dlls/ntdll/tests/thread.c
+++ b/dlls/ntdll/tests/thread.c
@@ -273,6 +273,129 @@ static void test_thread_bypass_process_freeze(void)
     CloseHandle( thread );
 }
 
+static void extract_resource(const char *name, const char *type, const char *path)
+{
+    DWORD written;
+    HANDLE file;
+    HRSRC res;
+    void *ptr;
+
+    file = CreateFileA(path, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
+    ok(file != INVALID_HANDLE_VALUE, "file creation failed, at %s, error %ld\n", path, GetLastError());
+
+    res = FindResourceA(NULL, name, type);
+    ok( res != 0, "couldn't find resource\n" );
+    ptr = LockResource( LoadResource( GetModuleHandleA(NULL), res ));
+    WriteFile( file, ptr, SizeofResource( GetModuleHandleA(NULL), res ), &written, NULL );
+    ok( written == SizeofResource( GetModuleHandleA(NULL), res ), "couldn't write resource\n" );
+    CloseHandle( file );
+}
+
+BOOL seen_tls_thread_attach;
+BOOL seen_tls_thread_detach;
+
+void WINAPI tls_callback(HANDLE instance, DWORD reason, LPVOID reserved)
+{
+    switch (reason)
+    {
+        case DLL_THREAD_ATTACH:
+            seen_tls_thread_attach = TRUE;
+            break;
+        case DLL_THREAD_DETACH:
+            seen_tls_thread_detach = TRUE;
+            break;
+    }
+}
+
+#define _CRTALLOC(x) __attribute__ ((section (x), used))
+
+__attribute__((used)) ULONG _tls_index = 0;
+
+_CRTALLOC(".tls") char *_tls_start = NULL;
+_CRTALLOC(".tls$ZZZ") char *_tls_end = NULL;
+
+_CRTALLOC(".CRT$XLA") PIMAGE_TLS_CALLBACK __xl_a = 0;
+
+_CRTALLOC(".CRT$XLC") PIMAGE_TLS_CALLBACK __xl_c = tls_callback;
+_CRTALLOC(".CRT$XLZ") PIMAGE_TLS_CALLBACK __xl_z = 0;
+
+__attribute__((used)) const IMAGE_TLS_DIRECTORY _tls_used = {
+  (ULONG_PTR) &_tls_start, (ULONG_PTR) &_tls_end,
+  (ULONG_PTR) &_tls_index, (ULONG_PTR) (&__xl_a+1),
+  (ULONG) 0, (ULONG) 0
+};
+
+struct skip_thread_attach_args
+{
+    BOOL teb_flag;
+    PVOID teb_tls_pointer;
+    PVOID teb_fls_slots;
+};
+
+static void CALLBACK test_skip_thread_attach_proc(void *param)
+{
+    struct skip_thread_attach_args *args = param;
+    args->teb_flag = NtCurrentTeb()->SkipThreadAttach;
+    args->teb_tls_pointer = NtCurrentTeb()->ThreadLocalStoragePointer;
+    args->teb_fls_slots = NtCurrentTeb()->FlsSlots;
+}
+
+static void test_skip_thread_attach(void)
+{
+    BOOL *seen_thread_attach, *seen_thread_detach;
+    struct skip_thread_attach_args args;
+    HANDLE thread;
+    NTSTATUS status;
+    char path_dll_local[MAX_PATH + 11];
+    char path_tmp[MAX_PATH];
+    HMODULE module = NULL;
+
+    if (!pNtCreateThreadEx)
+    {
+        win_skip( "NtCreateThreadEx is not available.\n" );
+        return;
+    }
+
+    GetTempPathA(sizeof(path_tmp), path_tmp);
+
+    sprintf(path_dll_local, "%s%s", path_tmp, "testdll.dll");
+    extract_resource("testdll.dll", "TESTDLL", path_dll_local);
+
+    module = LoadLibraryA(path_dll_local);
+    if (!module) {
+        trace("Could not load testdll.\n");
+        goto delete;
+    }
+
+    seen_thread_attach = (BOOL *)GetProcAddress(module, "seen_thread_attach");
+    seen_thread_detach = (BOOL *)GetProcAddress(module, "seen_thread_detach");
+    seen_tls_thread_attach = FALSE;
+    seen_tls_thread_detach = FALSE;
+
+    ok( !*seen_thread_attach, "Unexpected\n" );
+    ok( !*seen_thread_detach, "Unexpected\n" );
+
+    status = pNtCreateThreadEx( &thread, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(), test_skip_thread_attach_proc,
+                                &args, THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH, 0, 0, 0, NULL );
+    todo_wine ok( status == STATUS_SUCCESS, "Got unexpected status %#lx.\n", status );
+
+    WaitForSingleObject( thread, INFINITE );
+
+    CloseHandle( thread );
+
+    todo_wine ok( !*seen_thread_attach, "Unexpected\n" );
+    todo_wine ok( !*seen_thread_detach, "Unexpected\n" );
+    todo_wine ok( !seen_tls_thread_attach, "Unexpected\n" );
+    todo_wine ok( !seen_tls_thread_attach, "Unexpected\n" );
+    todo_wine ok( args.teb_flag, "Unexpected\n" );
+    todo_wine ok( !args.teb_tls_pointer, "Unexpected\n" );
+    todo_wine ok( !args.teb_fls_slots, "Unexpected\n" );
+
+    FreeLibrary(module);
+delete:
+    DeleteFileA(path_dll_local);
+}
+
 START_TEST(thread)
 {
     init_function_pointers();
@@ -282,4 +405,5 @@ START_TEST(thread)
     test_errno();
     test_NtCreateUserProcess();
     test_thread_bypass_process_freeze();
+    test_skip_thread_attach();
 }
diff --git a/include/winternl.h b/include/winternl.h
index c966f4c88e58..c9c64ca08d30 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -610,7 +610,27 @@ typedef struct _TEB
     PVOID                        MergedPrefLanguages;               /* fc0/17e0 */
     ULONG                        MuiImpersonation;                  /* fc4/17e8 */
     USHORT                       CrossTebFlags;                     /* fc8/17ec */
-    USHORT                       SameTebFlags;                      /* fca/17ee */
+    union {
+        USHORT SameTebFlags;                                        /* fca/17ee */
+        struct {
+            USHORT SafeThunkCall : 1;
+            USHORT InDebugPrint : 1;
+            USHORT HasFiberData : 1;
+            USHORT SkipThreadAttach : 1;
+            USHORT WerInShipAssertCode : 1;
+            USHORT RanProcessInit : 1;
+            USHORT ClonedThread : 1;
+            USHORT SuppressDebugMsg : 1;
+            USHORT DisableUserStackWalk : 1;
+            USHORT RtlExceptionAttached : 1;
+            USHORT InitialThread : 1;
+            USHORT SessionAware : 1;
+            USHORT LoadOwner : 1;
+            USHORT LoaderWorker : 1;
+            USHORT SkipLoaderInit : 1;
+            USHORT SkipFileAPIBrokering : 1;
+        } DUMMYSTRUCTNAME;
+    } DUMMYUNIONNAME1;
     PVOID                        TxnScopeEnterCallback;             /* fcc/17f0 */
     PVOID                        TxnScopeExitCallback;              /* fd0/17f8 */
     PVOID                        TxnScopeContext;                   /* fd4/1800 */
@@ -1143,7 +1163,27 @@ typedef struct _TEB32
     ULONG                        MergedPrefLanguages;               /* 0fc0 */
     ULONG                        MuiImpersonation;                  /* 0fc4 */
     USHORT                       CrossTebFlags;                     /* 0fc8 */
-    USHORT                       SameTebFlags;                      /* 0fca */
+    union {
+        USHORT SameTebFlags;                                        /* 0fca */
+        struct {
+            USHORT SafeThunkCall : 1;
+            USHORT InDebugPrint : 1;
+            USHORT HasFiberData : 1;
+            USHORT SkipThreadAttach : 1;
+            USHORT WerInShipAssertCode : 1;
+            USHORT RanProcessInit : 1;
+            USHORT ClonedThread : 1;
+            USHORT SuppressDebugMsg : 1;
+            USHORT DisableUserStackWalk : 1;
+            USHORT RtlExceptionAttached : 1;
+            USHORT InitialThread : 1;
+            USHORT SessionAware : 1;
+            USHORT LoadOwner : 1;
+            USHORT LoaderWorker : 1;
+            USHORT SkipLoaderInit : 1;
+            USHORT SkipFileAPIBrokering : 1;
+        } DUMMYSTRUCTNAME;
+    } DUMMYUNIONNAME1;
     ULONG                        TxnScopeEnterCallback;             /* 0fcc */
     ULONG                        TxnScopeExitCallback;              /* 0fd0 */
     ULONG                        TxnScopeContext;                   /* 0fd4 */
@@ -1249,7 +1289,27 @@ typedef struct _TEB64
     ULONG64                      MergedPrefLanguages;               /* 17e0 */
     ULONG                        MuiImpersonation;                  /* 17e8 */
     USHORT                       CrossTebFlags;                     /* 17ec */
-    USHORT                       SameTebFlags;                      /* 17ee */
+    union {
+        USHORT SameTebFlags;                                        /* 17ee */
+        struct {
+            USHORT SafeThunkCall : 1;
+            USHORT InDebugPrint : 1;
+            USHORT HasFiberData : 1;
+            USHORT SkipThreadAttach : 1;
+            USHORT WerInShipAssertCode : 1;
+            USHORT RanProcessInit : 1;
+            USHORT ClonedThread : 1;
+            USHORT SuppressDebugMsg : 1;
+            USHORT DisableUserStackWalk : 1;
+            USHORT RtlExceptionAttached : 1;
+            USHORT InitialThread : 1;
+            USHORT SessionAware : 1;
+            USHORT LoadOwner : 1;
+            USHORT LoaderWorker : 1;
+            USHORT SkipLoaderInit : 1;
+            USHORT SkipFileAPIBrokering : 1;
+        } DUMMYSTRUCTNAME;
+    } DUMMYUNIONNAME1;
     ULONG64                      TxnScopeEnterCallback;             /* 17f0 */
     ULONG64                      TxnScopeExitCallback;              /* 17f8 */
     ULONG64                      TxnScopeContext;                   /* 1800 */

From 7614c2d0cdf17c2dc96ece9c9db99a8a108c494d Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Mon, 11 Aug 2025 16:38:16 +0100
Subject: [PATCH 21/25] ntdll: Support THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH
 flag.

---
 dlls/ntdll/loader.c       | 12 ++++++++++++
 dlls/ntdll/tests/thread.c | 16 ++++++++--------
 dlls/ntdll/unix/thread.c  | 11 +++++++++--
 3 files changed, 29 insertions(+), 10 deletions(-)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index c9a91f192b69..3388dc1e1950 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -3909,6 +3909,11 @@ void WINAPI LdrShutdownThread(void)
     /* don't do any detach calls if process is exiting */
     if (process_detaching) return;
 
+    if (NtCurrentTeb()->SkipThreadAttach) {
+        heap_thread_detach();
+        return;
+    }
+
     RtlProcessFlsData( NtCurrentTeb()->FlsSlots, 1 );
 
     RtlEnterCriticalSection( &loader_section );
@@ -4475,6 +4480,13 @@ void loader_init( CONTEXT *context, void **entry )
 #ifdef __arm64ec__
         arm64ec_thread_init();
 #endif
+
+        if (NtCurrentTeb()->SkipThreadAttach)
+        {
+            RtlLeaveCriticalSection( &loader_section );
+            return;
+        }
+
         wm = get_modref( NtCurrentTeb()->Peb->ImageBaseAddress );
     }
 
diff --git a/dlls/ntdll/tests/thread.c b/dlls/ntdll/tests/thread.c
index 1988dcd95d82..e6c14a4cf234 100644
--- a/dlls/ntdll/tests/thread.c
+++ b/dlls/ntdll/tests/thread.c
@@ -377,19 +377,19 @@ static void test_skip_thread_attach(void)
 
     status = pNtCreateThreadEx( &thread, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(), test_skip_thread_attach_proc,
                                 &args, THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH, 0, 0, 0, NULL );
-    todo_wine ok( status == STATUS_SUCCESS, "Got unexpected status %#lx.\n", status );
+    ok( status == STATUS_SUCCESS, "Got unexpected status %#lx.\n", status );
 
     WaitForSingleObject( thread, INFINITE );
 
     CloseHandle( thread );
 
-    todo_wine ok( !*seen_thread_attach, "Unexpected\n" );
-    todo_wine ok( !*seen_thread_detach, "Unexpected\n" );
-    todo_wine ok( !seen_tls_thread_attach, "Unexpected\n" );
-    todo_wine ok( !seen_tls_thread_attach, "Unexpected\n" );
-    todo_wine ok( args.teb_flag, "Unexpected\n" );
-    todo_wine ok( !args.teb_tls_pointer, "Unexpected\n" );
-    todo_wine ok( !args.teb_fls_slots, "Unexpected\n" );
+    ok( !*seen_thread_attach, "Unexpected\n" );
+    ok( !*seen_thread_detach, "Unexpected\n" );
+    ok( !seen_tls_thread_attach, "Unexpected\n" );
+    ok( !seen_tls_thread_attach, "Unexpected\n" );
+    ok( args.teb_flag, "Unexpected\n" );
+    ok( !args.teb_tls_pointer, "Unexpected\n" );
+    ok( !args.teb_fls_slots, "Unexpected\n" );
 
     FreeLibrary(module);
 delete:
diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index 02d96c1a6fcd..c864b88caf20 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -1315,8 +1315,8 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE *handle, ACCESS_MASK access, OBJECT_ATT
                                   ULONG flags, ULONG_PTR zero_bits, SIZE_T stack_commit,
                                   SIZE_T stack_reserve, PS_ATTRIBUTE_LIST *attr_list )
 {
-    static const ULONG supported_flags = THREAD_CREATE_FLAGS_CREATE_SUSPENDED | THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER |
-                                         THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE;
+    static const ULONG supported_flags = THREAD_CREATE_FLAGS_CREATE_SUSPENDED | THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH |
+                                         THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER | THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE;
     sigset_t sigset;
     pthread_t pthread_id;
     pthread_attr_t pthread_attr;
@@ -1326,6 +1326,7 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE *handle, ACCESS_MASK access, OBJECT_ATT
     DWORD tid = 0;
     int request_pipe[2];
     TEB *teb;
+    WOW_TEB *wow_teb;
     unsigned int status;
 
     if (flags & ~supported_flags)
@@ -1411,6 +1412,12 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE *handle, ACCESS_MASK access, OBJECT_ATT
 
     set_thread_id( teb, GetCurrentProcessId(), tid );
 
+    teb->SkipThreadAttach = !!(flags & THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH);
+    wow_teb = get_wow_teb( teb );
+    if (wow_teb) {
+        wow_teb->SameTebFlags = teb->SameTebFlags;
+    }
+
     thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
     thread_data->request_fd  = request_pipe[1];
     thread_data->start = start;

From 158b9d9642fdb4d784aff251e4eddc7f7f026cc0 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Mon, 11 Aug 2025 16:40:01 +0100
Subject: [PATCH 22/25] ntdll/tests: Test THREAD_CREATE_FLAGS_SKIP_LOADER_INIT
 flag.

---
 dlls/ntdll/tests/thread.c | 77 ++++++++++++++++++++++++++++++++++++++-
 1 file changed, 76 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/tests/thread.c b/dlls/ntdll/tests/thread.c
index e6c14a4cf234..2fce6cb0ca56 100644
--- a/dlls/ntdll/tests/thread.c
+++ b/dlls/ntdll/tests/thread.c
@@ -31,8 +31,11 @@
 static NTSTATUS (WINAPI *pNtCreateThreadEx)( HANDLE *, ACCESS_MASK, OBJECT_ATTRIBUTES *,
                                              HANDLE, PRTL_THREAD_START_ROUTINE, void *,
                                              ULONG, ULONG_PTR, SIZE_T, SIZE_T, PS_ATTRIBUTE_LIST * );
+static NTSTATUS (WINAPI *pNtAllocateVirtualMemoryEx)(HANDLE, PVOID *, SIZE_T *, ULONG, ULONG,
+                                                     MEM_EXTENDED_PARAMETER *, ULONG);
 static NTSTATUS  (WINAPI *pNtSuspendProcess)(HANDLE process);
 static NTSTATUS  (WINAPI *pNtResumeProcess)(HANDLE process);
+static NTSTATUS (WINAPI *pRtlWow64GetProcessMachines)(HANDLE,WORD*,WORD*);
 
 static int * (CDECL *p_errno)(void);
 
@@ -41,8 +44,10 @@ static void init_function_pointers(void)
     HMODULE hntdll = GetModuleHandleA( "ntdll.dll" );
 #define GET_FUNC(name) p##name = (void *)GetProcAddress( hntdll, #name );
     GET_FUNC( NtCreateThreadEx );
+    GET_FUNC( NtAllocateVirtualMemoryEx );
     GET_FUNC( NtSuspendProcess );
     GET_FUNC( NtResumeProcess );
+    GET_FUNC( RtlWow64GetProcessMachines );
     GET_FUNC( _errno );
 #undef GET_FUNC
 }
@@ -392,10 +397,69 @@ static void test_skip_thread_attach(void)
     ok( !args.teb_fls_slots, "Unexpected\n" );
 
     FreeLibrary(module);
-delete:
     DeleteFileA(path_dll_local);
 }
 
+struct test_skip_load_init_args
+{
+    USHORT teb_same_teb_flags;
+};
+
+static ULONG patched_code[] =
+{
+    0xd282fdc2, /* mov x2, #0x17ee */
+    0x78626a41, /* ldrh w1, [x18, x2]   (NtCurrentTeb()->SameTebFlags) */
+    0x79000001, /* strh w1, [x0]        (args->teb_same_teb_flags)     */
+    0xd65f03c0, /* ret */
+};
+
+static void test_arm64_skip_loader_init(void)
+{
+    struct test_skip_load_init_args args;
+    HANDLE thread;
+    NTSTATUS status;
+    void *code_mem = NULL;
+#ifdef __x86_64__
+    MEM_EXTENDED_PARAMETER param = { 0 };
+    SIZE_T code_size = 0x10000;
+
+    param.Type = MemExtendedParameterAttributeFlags;
+    param.ULong64 = MEM_EXTENDED_PARAMETER_EC_CODE;
+    if (!pNtAllocateVirtualMemoryEx ||
+        pNtAllocateVirtualMemoryEx( GetCurrentProcess(), &code_mem, &code_size, MEM_RESERVE | MEM_COMMIT,
+                                    PAGE_EXECUTE_READWRITE, &param, 1 ))
+    {
+        trace("NtAllocateVirtualMemoryEx failed\n");
+        return;
+
+    }
+#else
+    code_mem = VirtualAlloc(NULL, 65536, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
+    if (!code_mem) {
+        trace("VirtualAlloc failed\n");
+        return;
+    }
+#endif
+    if (!pNtCreateThreadEx)
+    {
+        win_skip( "NtCreateThreadEx is not available.\n" );
+        return;
+    }
+
+    memcpy(code_mem, patched_code, sizeof(patched_code));
+
+    status = pNtCreateThreadEx( &thread, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(), (PRTL_THREAD_START_ROUTINE)code_mem,
+                                &args, THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH | THREAD_CREATE_FLAGS_SKIP_LOADER_INIT, 0, 0, 0, NULL );
+
+    todo_wine ok( status == STATUS_SUCCESS, "Got unexpected status %#lx.\n", status );
+
+    WaitForSingleObject( thread, INFINITE );
+
+    todo_wine ok( (args.teb_same_teb_flags & 0x4008) == 0x4008, "wrong value %x\n", args.teb_same_teb_flags );
+
+    CloseHandle( thread );
+}
+
 START_TEST(thread)
 {
     init_function_pointers();
@@ -406,4 +470,15 @@ START_TEST(thread)
     test_NtCreateUserProcess();
     test_thread_bypass_process_freeze();
     test_skip_thread_attach();
+
+    if (pRtlWow64GetProcessMachines)
+    {
+        USHORT current, native;
+        NTSTATUS status = pRtlWow64GetProcessMachines( GetCurrentProcess(), &current, &native );
+        if (!status && native == IMAGE_FILE_MACHINE_ARM64)
+        {
+            trace( "Running arm64 tests.\n" );
+            test_arm64_skip_loader_init();
+        }
+    }
 }

From e4585848227ad8712e205f58de90af7b946d749b Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Mon, 11 Aug 2025 16:43:16 +0100
Subject: [PATCH 23/25] ntdll: Add a default pBaseThreadInitThunk
 implementation.

The native arch kernel32.dll isn't loaded in WOW64 mode, but threads can still
be created if the SKIP_LOADER_INIT flag is set, provide a default implementation
to support this.
---
 dlls/ntdll/loader.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 3388dc1e1950..11a662627d5a 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -69,7 +69,8 @@ static const WCHAR pe_dir[] = L"";
 typedef DWORD (CALLBACK *DLLENTRYPROC)(HMODULE,DWORD,LPVOID);
 typedef void  (CALLBACK *LDRENUMPROC)(LDR_DATA_TABLE_ENTRY *, void *, BOOLEAN *);
 
-void (FASTCALL *pBaseThreadInitThunk)(DWORD,LPTHREAD_START_ROUTINE,void *) = NULL;
+static void __fastcall default_thread_init_func( DWORD unknown, LPTHREAD_START_ROUTINE entry, void *arg );
+void (FASTCALL *pBaseThreadInitThunk)(DWORD,LPTHREAD_START_ROUTINE,void *) = default_thread_init_func;
 NTSTATUS (WINAPI *__wine_unix_call_dispatcher)( unixlib_handle_t, unsigned int, void * ) = NULL;
 
 static DWORD (WINAPI *pCtrlRoutine)(void *);
@@ -220,6 +221,11 @@ static RTL_UNLOAD_EVENT_TRACE unload_traces[RTL_UNLOAD_EVENT_TRACE_NUMBER];
 static RTL_UNLOAD_EVENT_TRACE *unload_trace_ptr;
 static unsigned int unload_trace_seq;
 
+static void __fastcall default_thread_init_func( DWORD unknown, LPTHREAD_START_ROUTINE entry, void *arg )
+{
+    RtlExitUserThread( entry( arg ) );
+}
+
 static void module_push_unload_trace( const WINE_MODREF *wm )
 {
     RTL_UNLOAD_EVENT_TRACE *ptr = &unload_traces[unload_trace_seq];

From 20180dfdd576780eb3d7927e71a13952c26d2a6f Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Mon, 11 Aug 2025 16:46:41 +0100
Subject: [PATCH 24/25] ntdll: Support THREAD_CREATE_FLAGS_SKIP_LOADER_INIT
 flag.

I confirmed that ARM64EC BT thread creation callbacks aren't called through
some logging in FEX.
---
 dlls/ntdll/loader.c       | 2 ++
 dlls/ntdll/tests/thread.c | 4 ++--
 dlls/ntdll/unix/thread.c  | 4 +++-
 3 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 11a662627d5a..9a4fd831e9ff 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -4404,6 +4404,8 @@ void loader_init( CONTEXT *context, void **entry )
 
     if (process_detaching) NtTerminateThread( GetCurrentThread(), 0 );
 
+    if (NtCurrentTeb()->SkipLoaderInit) return;
+
     RtlEnterCriticalSection( &loader_section );
 
     if (!imports_fixup_done)
diff --git a/dlls/ntdll/tests/thread.c b/dlls/ntdll/tests/thread.c
index 2fce6cb0ca56..003ce03a556d 100644
--- a/dlls/ntdll/tests/thread.c
+++ b/dlls/ntdll/tests/thread.c
@@ -451,11 +451,11 @@ static void test_arm64_skip_loader_init(void)
     status = pNtCreateThreadEx( &thread, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(), (PRTL_THREAD_START_ROUTINE)code_mem,
                                 &args, THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH | THREAD_CREATE_FLAGS_SKIP_LOADER_INIT, 0, 0, 0, NULL );
 
-    todo_wine ok( status == STATUS_SUCCESS, "Got unexpected status %#lx.\n", status );
+    ok( status == STATUS_SUCCESS, "Got unexpected status %#lx.\n", status );
 
     WaitForSingleObject( thread, INFINITE );
 
-    todo_wine ok( (args.teb_same_teb_flags & 0x4008) == 0x4008, "wrong value %x\n", args.teb_same_teb_flags );
+    ok( (args.teb_same_teb_flags & 0x4008) == 0x4008, "wrong value %x\n", args.teb_same_teb_flags );
 
     CloseHandle( thread );
 }
diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index c864b88caf20..e26ddf99a67a 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -1316,7 +1316,8 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE *handle, ACCESS_MASK access, OBJECT_ATT
                                   SIZE_T stack_reserve, PS_ATTRIBUTE_LIST *attr_list )
 {
     static const ULONG supported_flags = THREAD_CREATE_FLAGS_CREATE_SUSPENDED | THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH |
-                                         THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER | THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE;
+                                         THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER | THREAD_CREATE_FLAGS_SKIP_LOADER_INIT |
+                                         THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE;
     sigset_t sigset;
     pthread_t pthread_id;
     pthread_attr_t pthread_attr;
@@ -1413,6 +1414,7 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE *handle, ACCESS_MASK access, OBJECT_ATT
     set_thread_id( teb, GetCurrentProcessId(), tid );
 
     teb->SkipThreadAttach = !!(flags & THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH);
+    teb->SkipLoaderInit = !!(flags & THREAD_CREATE_FLAGS_SKIP_LOADER_INIT);
     wow_teb = get_wow_teb( teb );
     if (wow_teb) {
         wow_teb->SameTebFlags = teb->SameTebFlags;

From fcc776b804b99bf6bbc69f5a8345d269a764972c Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Mon, 11 Aug 2025 21:56:19 +0100
Subject: [PATCH 25/25] ntdll: Support cross-process wow64 suspend on ARM64.

---
 dlls/ntdll/signal_arm64.c | 62 +++++++++++++++++++++++++++++++++++----
 1 file changed, 56 insertions(+), 6 deletions(-)

diff --git a/dlls/ntdll/signal_arm64.c b/dlls/ntdll/signal_arm64.c
index 548f87a3a6ee..ac861b6dc0ce 100644
--- a/dlls/ntdll/signal_arm64.c
+++ b/dlls/ntdll/signal_arm64.c
@@ -643,19 +643,69 @@ BOOLEAN WINAPI RtlIsProcessorFeaturePresent( UINT feature )
             user_shared_data->ProcessorFeatures[feature]);
 }
 
+static void suspend_remote_breakin( HANDLE thread )
+{
+    ULONG count;
+    NTSTATUS status = pWow64SuspendLocalThread( thread, &count );
+    if (status >= 0) status = count;
+    NtTerminateThread( GetCurrentThread(),  status );
+}
+
 /***********************************************************************
  *              RtlWow64SuspendThread (NTDLL.@)
  */
 NTSTATUS WINAPI RtlWow64SuspendThread( HANDLE thread, ULONG *count )
 {
+    HANDLE thread_dup;
     THREAD_BASIC_INFORMATION tbi;
+    NTSTATUS status = NtDuplicateObject( NtCurrentProcess(), thread, NtCurrentProcess(), &thread_dup,
+                                         THREAD_QUERY_INFORMATION | THREAD_SUSPEND_RESUME, 0, 0 );
+    if (status) return status;
+    status = NtQueryInformationThread( thread_dup, ThreadBasicInformation, &tbi, sizeof(tbi), NULL);
+    NtClose( thread_dup );
+    if (status) return status;
+
+    if (tbi.ClientId.UniqueProcess != NtCurrentTeb()->ClientId.UniqueProcess)
+    {
+        HANDLE process;
+        HANDLE suspender_thread;
+        HANDLE remote_suspendee_thread;
+        OBJECT_ATTRIBUTES attr = { .Length = sizeof(attr) };
+
+        status = NtOpenProcess( &process, PROCESS_CREATE_THREAD | PROCESS_DUP_HANDLE, &attr, &tbi.ClientId );
+        if (status) return status;
+
+        status = NtDuplicateObject( NtCurrentProcess(), thread, process, &remote_suspendee_thread, 0, 0,
+                                    DUPLICATE_SAME_ACCESS );
+        if (status) goto err_close_proc;
+
+        status = NtCreateThreadEx( &suspender_thread, SYNCHRONIZE | THREAD_QUERY_INFORMATION, NULL, process,
+                                   suspend_remote_breakin, remote_suspendee_thread,
+                                   THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH | THREAD_CREATE_FLAGS_SKIP_LOADER_INIT |
+                                   THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER | THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE,
+                                   0, 0, 0, NULL );
+        if (status) goto err_close_remote_hnd;
+
+        NtWaitForSingleObject( suspender_thread, FALSE, NULL );
+        status = NtQueryInformationThread( suspender_thread, ThreadBasicInformation, &tbi, sizeof(tbi), NULL );
+        if (!status)
+        {
+            if (tbi.ExitStatus < 0)
+            {
+                status = tbi.ExitStatus;
+            }
+            else if (count)
+            {
+                *count = (ULONG)tbi.ExitStatus;
+            }
+        }
 
-    NTSTATUS ret = NtQueryInformationThread( thread, ThreadBasicInformation, &tbi, sizeof(tbi), NULL);
-    if (ret) return ret;
-
-    if (tbi.ClientId.UniqueProcess != NtCurrentTeb()->ClientId.UniqueProcess) {
-        FIXME( "Non-local process thread suspend\n" );
-        return STATUS_SUCCESS;
+        NtClose( suspender_thread );
+err_close_remote_hnd:
+        NtDuplicateObject( process, remote_suspendee_thread, NULL, NULL, 0, 0, DUPLICATE_CLOSE_SOURCE );
+err_close_proc:
+        NtClose( process );
+        return status;
     }
 
     return pWow64SuspendLocalThread( thread, count );
