From 4c55868f297883fc1ddb119ceca8e93fa37c52ef Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Thu, 27 Jul 2023 08:00:43 -0700
Subject: [PATCH 01/16] ntdll: Implement WOW64 thread suspension helpers.

---
 dlls/ntdll/loader.c         |  2 ++
 dlls/ntdll/ntdll.spec       |  1 +
 dlls/ntdll/ntdll_misc.h     |  1 +
 dlls/ntdll/signal_arm64.c   | 17 +++++++++++++++++
 dlls/ntdll/signal_arm64ec.c |  7 +++++++
 dlls/ntdll/signal_x86_64.c  |  7 +++++++
 include/winternl.h          |  1 +
 7 files changed, 36 insertions(+)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 6b089c990b57..7a307b33f22b 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -4273,6 +4273,7 @@ static void build_wow64_main_module(void)
 static void (WINAPI *pWow64LdrpInitialize)( CONTEXT *ctx );
 
 void (WINAPI *pWow64PrepareForException)( EXCEPTION_RECORD *rec, CONTEXT *context ) = NULL;
+NTSTATUS (WINAPI *pWow64SuspendLocalThread)( HANDLE thread, ULONG *count ) = NULL;
 
 static void init_wow64( CONTEXT *context )
 {
@@ -4297,6 +4298,7 @@ static void init_wow64( CONTEXT *context )
 
         GET_PTR( Wow64LdrpInitialize );
         GET_PTR( Wow64PrepareForException );
+        GET_PTR( Wow64SuspendLocalThread );
 #undef GET_PTR
         imports_fixup_done = TRUE;
     }
diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index 8d14ae393be2..93ef6c2e0a38 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -1142,6 +1142,7 @@
 @ stdcall -arch=win64 RtlWow64PushCrossProcessWorkOntoWorkList(ptr ptr ptr)
 @ stdcall -arch=win64 RtlWow64RequestCrossProcessHeavyFlush(ptr)
 @ stdcall -arch=win64 RtlWow64SetThreadContext(long ptr)
+@ stdcall -arch=win64 RtlWow64SuspendThread(long ptr)
 @ stub RtlWriteMemoryStream
 @ stdcall RtlWriteRegistryValue(long ptr wstr long ptr long)
 @ stub RtlZeroHeap
diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
index 99e0aceeef30..d8de8fb32e91 100644
--- a/dlls/ntdll/ntdll_misc.h
+++ b/dlls/ntdll/ntdll_misc.h
@@ -76,6 +76,7 @@ extern void WINAPI KiUserApcDispatcher(CONTEXT*,ULONG_PTR,ULONG_PTR,ULONG_PTR,PN
 extern void WINAPI KiUserCallbackDispatcher(ULONG,void*,ULONG);
 extern void WINAPI KiUserCallbackDispatcherReturn(void);
 extern void (WINAPI *pWow64PrepareForException)( EXCEPTION_RECORD *rec, CONTEXT *context );
+extern NTSTATUS (WINAPI *pWow64SuspendLocalThread)( HANDLE thread, ULONG *count );
 
 /* debug helpers */
 extern LPCSTR debugstr_us( const UNICODE_STRING *str );
diff --git a/dlls/ntdll/signal_arm64.c b/dlls/ntdll/signal_arm64.c
index bc981289ea5a..548f87a3a6ee 100644
--- a/dlls/ntdll/signal_arm64.c
+++ b/dlls/ntdll/signal_arm64.c
@@ -643,6 +643,23 @@ BOOLEAN WINAPI RtlIsProcessorFeaturePresent( UINT feature )
             user_shared_data->ProcessorFeatures[feature]);
 }
 
+/***********************************************************************
+ *              RtlWow64SuspendThread (NTDLL.@)
+ */
+NTSTATUS WINAPI RtlWow64SuspendThread( HANDLE thread, ULONG *count )
+{
+    THREAD_BASIC_INFORMATION tbi;
+
+    NTSTATUS ret = NtQueryInformationThread( thread, ThreadBasicInformation, &tbi, sizeof(tbi), NULL);
+    if (ret) return ret;
+
+    if (tbi.ClientId.UniqueProcess != NtCurrentTeb()->ClientId.UniqueProcess) {
+        FIXME( "Non-local process thread suspend\n" );
+        return STATUS_SUCCESS;
+    }
+
+    return pWow64SuspendLocalThread( thread, count );
+}
 
 /*************************************************************************
  *		RtlWalkFrameChain (NTDLL.@)
diff --git a/dlls/ntdll/signal_arm64ec.c b/dlls/ntdll/signal_arm64ec.c
index 1cb587fa4476..241b940219cc 100644
--- a/dlls/ntdll/signal_arm64ec.c
+++ b/dlls/ntdll/signal_arm64ec.c
@@ -1768,6 +1768,13 @@ BOOLEAN WINAPI RtlIsProcessorFeaturePresent( UINT feature )
     return emulated_processor_features[feature];
 }
 
+/***********************************************************************
+ *              RtlWow64SuspendThread (NTDLL.@)
+ */
+NTSTATUS WINAPI RtlWow64SuspendThread( HANDLE thread, ULONG *count )
+{
+    return NtSuspendThread( thread, count );
+}
 
 /*************************************************************************
  *		RtlWalkFrameChain (NTDLL.@)
diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
index ad9557ca9062..2e5980529cac 100644
--- a/dlls/ntdll/signal_x86_64.c
+++ b/dlls/ntdll/signal_x86_64.c
@@ -844,6 +844,13 @@ BOOLEAN WINAPI RtlIsProcessorFeaturePresent( UINT feature )
     return feature < PROCESSOR_FEATURE_MAX && user_shared_data->ProcessorFeatures[feature];
 }
 
+/***********************************************************************
+ *              RtlWow64SuspendThread (NTDLL.@)
+ */
+NTSTATUS WINAPI RtlWow64SuspendThread( HANDLE thread, ULONG *count )
+{
+    return NtSuspendThread( thread, count );
+}
 
 /*************************************************************************
  *		RtlWalkFrameChain (NTDLL.@)
diff --git a/include/winternl.h b/include/winternl.h
index 0bf166b89963..9bc5d0dac033 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -5110,6 +5110,7 @@ NTSYSAPI USHORT    WINAPI RtlWow64GetCurrentMachine(void);
 NTSYSAPI NTSTATUS  WINAPI RtlWow64GetProcessMachines(HANDLE,USHORT*,USHORT*);
 NTSYSAPI NTSTATUS  WINAPI RtlWow64GetSharedInfoProcess(HANDLE,BOOLEAN*,WOW64INFO*);
 NTSYSAPI NTSTATUS  WINAPI RtlWow64IsWowGuestMachineSupported(USHORT,BOOLEAN*);
+NTSYSAPI NTSTATUS  WINAPI RtlWow64SuspendThread(HANDLE,ULONG*);
 NTSYSAPI NTSTATUS  WINAPI RtlWriteRegistryValue(ULONG,PCWSTR,PCWSTR,ULONG,PVOID,ULONG);
 NTSYSAPI NTSTATUS  WINAPI RtlZombifyActivationContext(struct _ACTIVATION_CONTEXT *);
 NTSYSAPI NTSTATUS  WINAPI RtlpNtCreateKey(PHANDLE,ACCESS_MASK,const OBJECT_ATTRIBUTES*,ULONG,const UNICODE_STRING*,ULONG,PULONG);

From c1b87071d7baa6efdade18be3e65d30ccd4075e8 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Thu, 27 Jul 2023 08:20:59 -0700
Subject: [PATCH 02/16] wow64: Support running a BT module provided suspend
 routine.

Suspension in JITs cannot easily be handled on the unix side, so allow BT
modules to provide their own suspend helper.
---
 dlls/wow64/process.c  |  2 +-
 dlls/wow64/syscall.c  | 10 ++++++++++
 dlls/wow64/wow64.spec |  2 +-
 3 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/dlls/wow64/process.c b/dlls/wow64/process.c
index 957ca0d2691e..7b214d770eb6 100644
--- a/dlls/wow64/process.c
+++ b/dlls/wow64/process.c
@@ -1079,7 +1079,7 @@ NTSTATUS WINAPI wow64_NtSuspendThread( UINT *args )
     HANDLE handle = get_handle( &args );
     ULONG *count = get_ptr( &args );
 
-    return NtSuspendThread( handle, count );
+    return RtlWow64SuspendThread( handle, count );
 }
 
 
diff --git a/dlls/wow64/syscall.c b/dlls/wow64/syscall.c
index d2a977ee5adb..fbc687cc02a2 100644
--- a/dlls/wow64/syscall.c
+++ b/dlls/wow64/syscall.c
@@ -102,6 +102,7 @@ static void     (WINAPI *pBTCpuProcessInit)(void);
 static NTSTATUS (WINAPI *pBTCpuSetContext)(HANDLE,HANDLE,void *,void *);
 static void     (WINAPI *pBTCpuThreadInit)(void);
 static void     (WINAPI *pBTCpuSimulate)(void) __attribute__((used));
+static NTSTATUS (WINAPI *pBTCpuSuspendLocalThread)(HANDLE,ULONG *);
 static void *   (WINAPI *p__wine_get_unix_opcode)(void);
 static void *   (WINAPI *pKiRaiseUserExceptionDispatcher)(void);
 void     (WINAPI *pBTCpuFlushInstructionCache2)( const void *, SIZE_T ) = NULL;
@@ -839,6 +840,7 @@ static DWORD WINAPI process_init( RTL_RUN_ONCE *once, void *param, void **contex
     GET_PTR( BTCpuProcessInit );
     GET_PTR( BTCpuThreadInit );
     GET_PTR( BTCpuResetToConsistentState );
+    GET_PTR( BTCpuSuspendLocalThread );
     GET_PTR( BTCpuSetContext );
     GET_PTR( BTCpuSimulate );
     GET_PTR( BTCpuFlushInstructionCache2 );
@@ -1525,3 +1527,11 @@ NTSTATUS WINAPI Wow64RaiseException( int code, EXCEPTION_RECORD *rec )
 
     return STATUS_SUCCESS;
 }
+
+/**********************************************************************
+ *            Wow64SuspendLocalThread (wow64.@)
+ */
+NTSTATUS WINAPI Wow64SuspendLocalThread( HANDLE thread, ULONG *count )
+{
+    return pBTCpuSuspendLocalThread( thread, count );
+}
diff --git a/dlls/wow64/wow64.spec b/dlls/wow64/wow64.spec
index 5b4e565e5936..8f95dfcdbe52 100644
--- a/dlls/wow64/wow64.spec
+++ b/dlls/wow64/wow64.spec
@@ -22,7 +22,7 @@
 @ stub Wow64ShallowThunkAllocSecurityQualityOfService32TO64_FNC
 @ stub Wow64ShallowThunkSIZE_T32TO64
 @ stub Wow64ShallowThunkSIZE_T64TO32
-@ stub Wow64SuspendLocalThread
+@ stdcall Wow64SuspendLocalThread(long ptr)
 @ stdcall -norelay Wow64SystemServiceEx(long ptr)
 @ stub Wow64ValidateUserCallTarget
 @ stub Wow64ValidateUserCallTargetFilter

From cb65343d67ad50385470bd15618492a0d4bb02e5 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Fri, 12 Apr 2024 20:54:16 +0000
Subject: [PATCH 03/16] HACK: server: Map within the 39-bit address space on
 arm64.

---
 server/mapping.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/server/mapping.c b/server/mapping.c
index c3f57b6394c1..11ee3e7f858e 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -269,7 +269,11 @@ void init_memory(void)
 {
     host_page_mask = sysconf( _SC_PAGESIZE ) - 1;
     free_map_addr( 0x60000000, 0x1c000000 );
+#ifdef __aarch64__
+    free_map_addr( 0x4000000000, 0x1000000000 );
+#else
     free_map_addr( 0x600000000000, 0x100000000000 );
+#endif
 }
 
 static void ranges_dump( struct object *obj, int verbose )

From ff1c9ebff1407b63db9593dd48c19a40adefd615 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Wed, 17 Apr 2024 18:50:05 +0000
Subject: [PATCH 04/16] ntdll: Force all wow64 host allocations outside of the
 32-bit AS.

---
 dlls/ntdll/unix/virtual.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index e733e3ffdd66..cb060605205c 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -4960,6 +4960,9 @@ static NTSTATUS allocate_virtual_memory( void **ret, SIZE_T *size_ptr, ULONG typ
     {
         base = NULL;
         size = ROUND_SIZE( 0, size, page_mask );
+#ifdef _WIN64
+        if (is_wow64() && (!limit_high || limit_high > limit_4g)) limit_low = limit_4g;
+#endif
     }
 
     /* Compute the alloc type flags */

From 1897e6823d00dcda7923ac4eff3b1d69c2c37b78 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Fri, 19 Apr 2024 20:25:30 +0000
Subject: [PATCH 05/16] HACK: Use x86 mono on aarch64.

---
 dlls/appwiz.cpl/addons.c | 4 ++--
 dlls/mscoree/metahost.c  | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/dlls/appwiz.cpl/addons.c b/dlls/appwiz.cpl/addons.c
index 65d13a66c344..49428a7b64fa 100644
--- a/dlls/appwiz.cpl/addons.c
+++ b/dlls/appwiz.cpl/addons.c
@@ -48,7 +48,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(appwizcpl);
 #ifdef __i386__
 #define GECKO_ARCH "x86"
 #define GECKO_SHA "26cecc47706b091908f7f814bddb074c61beb8063318e9efc5a7f789857793d6"
-#elif defined(__x86_64__)
+#elif defined(__x86_64__) || defined(__aarch64__)
 #define GECKO_ARCH "x86_64"
 #define GECKO_SHA "e590b7d988a32d6aa4cf1d8aa3aa3d33766fdd4cf4c89c2dcc2095ecb28d066f"
 #else
@@ -57,7 +57,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(appwizcpl);
 #endif
 
 #define MONO_VERSION "10.1.0"
-#if defined(__i386__) || defined(__x86_64__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__aarch64__)
 #define MONO_ARCH "x86"
 #define MONO_SHA "c88c2431890bc32cacec8d7ea70e53a5ae4b95c8c55ca6e75ef8db0e4ccf1070"
 #else
diff --git a/dlls/mscoree/metahost.c b/dlls/mscoree/metahost.c
index 0e34d7388a0f..a4ff9fd90268 100644
--- a/dlls/mscoree/metahost.c
+++ b/dlls/mscoree/metahost.c
@@ -711,7 +711,7 @@ HRESULT ICLRRuntimeInfo_GetRuntimeHost(ICLRRuntimeInfo *iface, RuntimeHost **res
 
 #ifdef __i386__
 static const WCHAR libmono2_arch_dll[] = {'\\','b','i','n','\\','l','i','b','m','o','n','o','-','2','.','0','-','x','8','6','.','d','l','l',0};
-#elif defined(__x86_64__)
+#elif defined(__x86_64__) || defined(__aarch64__)
 static const WCHAR libmono2_arch_dll[] = {'\\','b','i','n','\\','l','i','b','m','o','n','o','-','2','.','0','-','x','8','6','_','6','4','.','d','l','l',0};
 #else
 static const WCHAR libmono2_arch_dll[] = {'\\','b','i','n','\\','l','i','b','m','o','n','o','-','2','.','0','.','d','l','l',0};

From d9cdb88bd37c4154673d602345ba1704f8e9ca52 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Tue, 23 Apr 2024 12:58:04 +0000
Subject: [PATCH 06/16] configure: Enable vcruntime140_1 and dpnsvcr for arm64x
 builds.

---
 configure.ac                            | 4 ++--
 dlls/vcruntime140_1/vcruntime140_1.spec | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/configure.ac b/configure.ac
index b4ede761391f..332fd641986d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2371,7 +2371,7 @@ esac
 
 dnl *** Check for modules to disable by default
 
-enable_vcruntime140_1=${enable_vcruntime140_1:-x86_64,arm64ec}
+enable_vcruntime140_1=${enable_vcruntime140_1:-x86_64,arm64ec,aarch64}
 
 if test -n "$PE_ARCHS"
 then
@@ -2401,7 +2401,7 @@ enable_wuauserv=${enable_wuauserv:-$HOST_ARCH}
 dnl Explicitly enable some programs for arm64ec
 enable_cmd=${enable_cmd:-yes}
 enable_dllhost=${enable_dllhost:-yes}
-enable_dpnsvr=${enable_dpnsvr:-i386,x86_64,arm64ec}
+enable_dpnsvr=${enable_dpnsvr:-i386,x86_64,arm64ec,aarch64}
 enable_dxdiag=${enable_dxdiag:-yes}
 enable_msiexec=${enable_msiexec:-yes}
 enable_netsh=${enable_netsh:-yes}
diff --git a/dlls/vcruntime140_1/vcruntime140_1.spec b/dlls/vcruntime140_1/vcruntime140_1.spec
index 0b126fa95d46..af295940a61a 100644
--- a/dlls/vcruntime140_1/vcruntime140_1.spec
+++ b/dlls/vcruntime140_1/vcruntime140_1.spec
@@ -1,3 +1,3 @@
-@ cdecl __CxxFrameHandler4(ptr long ptr ptr)
+@ cdecl -arch=arm64ec,x86_64 __CxxFrameHandler4(ptr long ptr ptr)
 @ stub __NLG_Dispatch2
 @ stub __NLG_Return2

From 23a3ded53d3ae77bbd337b9af45256cd2ecc16ca Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Mon, 19 Aug 2024 20:29:50 +0000
Subject: [PATCH 07/16] include: Add arm64 SVE xstate headers.

---
 include/winnt.h | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/include/winnt.h b/include/winnt.h
index e776312f9227..9e64648ea7ab 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -1475,6 +1475,10 @@ typedef struct _KNONVOLATILE_CONTEXT_POINTERS
 #define XSTATE_MASK_LEGACY                  (XSTATE_MASK_LEGACY_FLOATING_POINT | XSTATE_MASK_LEGACY_SSE)
 #define XSTATE_MASK_GSSE                    (1 << XSTATE_GSSE)
 
+#define XSTATE_ARM64_SVE 2
+
+#define XSTATE_MASK_ARM64_SVE (1 << XSTATE_ARM64_SVE)
+
 typedef struct _XSTATE_FEATURE
 {
     ULONG Offset;
@@ -1515,6 +1519,13 @@ typedef struct _XSAVE_AREA_HEADER
 }
 XSAVE_AREA_HEADER, *PXSAVE_AREA_HEADER;
 
+typedef struct _XSAVE_ARM64_SVE_HEADER {
+    ULONG VectorLength;
+    ULONG VectorRegisterOffset;
+    ULONG PredicateRegisterOffset;
+    ULONG Reserved[5];
+} XSAVE_ARM64_SVE_HEADER, *PXSAVE_ARM64_SVE_HEADER;
+
 typedef struct _YMMCONTEXT
 {
     M128A Ymm0;
@@ -1695,6 +1706,7 @@ typedef struct _KNONVOLATILE_CONTEXT_POINTERS
 #define CONTEXT_ARM64_FLOATING_POINT  (CONTEXT_ARM64 | 0x00000004)
 #define CONTEXT_ARM64_DEBUG_REGISTERS (CONTEXT_ARM64 | 0x00000008)
 #define CONTEXT_ARM64_X18       (CONTEXT_ARM64 | 0x00000010)
+#define CONTEXT_ARM64_XSTATE    (CONTEXT_ARM64 | 0x00000020)
 #define CONTEXT_ARM64_FULL (CONTEXT_ARM64_CONTROL | CONTEXT_ARM64_INTEGER | CONTEXT_ARM64_FLOATING_POINT)
 #define CONTEXT_ARM64_ALL  (CONTEXT_ARM64_FULL | CONTEXT_ARM64_DEBUG_REGISTERS | CONTEXT_ARM64_X18)
 
@@ -1974,6 +1986,7 @@ typedef struct DECLSPEC_ALIGN(16) _ARM64EC_NT_CONTEXT
 #define CONTEXT_INTEGER CONTEXT_ARM64_INTEGER
 #define CONTEXT_FLOATING_POINT CONTEXT_ARM64_FLOATING_POINT
 #define CONTEXT_DEBUG_REGISTERS CONTEXT_ARM64_DEBUG_REGISTERS
+#define CONTEXT_XSTATE CONTEXT_ARM64_XSTATE
 #define CONTEXT_FULL CONTEXT_ARM64_FULL
 #define CONTEXT_ALL CONTEXT_ARM64_ALL
 #define CONTEXT_RET_TO_GUEST CONTEXT_ARM64_RET_TO_GUEST

From 1df710b22956fcc6b159388db07572540ac6b34d Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Wed, 21 Aug 2024 22:26:28 +0000
Subject: [PATCH 08/16] FEX specific AVX support for arm64ec

---
 dlls/ntdll/signal_arm64ec.c | 56 ++++++++++++++++++++++++-------------
 dlls/ntdll/signal_x86_64.c  |  2 +-
 dlls/ntdll/unix/system.c    | 19 +++++++++++++
 dlls/ntdll/unwind.h         | 16 +++++++++++
 include/winnt.h             |  5 ++--
 5 files changed, 75 insertions(+), 23 deletions(-)

diff --git a/dlls/ntdll/signal_arm64ec.c b/dlls/ntdll/signal_arm64ec.c
index 241b940219cc..09b1050a65a8 100644
--- a/dlls/ntdll/signal_arm64ec.c
+++ b/dlls/ntdll/signal_arm64ec.c
@@ -36,6 +36,11 @@
 #include "wine/debug.h"
 #include "ntsyscalls.h"
 
+union ARM64EC_NT_XCONTEXT {
+    ARM64EC_NT_CONTEXT context;
+    BYTE buffer[0x800];
+};
+
 WINE_DEFAULT_DEBUG_CHANNEL(seh);
 WINE_DECLARE_DEBUG_CHANNEL(relay);
 
@@ -1220,7 +1225,11 @@ NTSTATUS call_seh_handlers( EXCEPTION_RECORD *rec, CONTEXT *orig_context )
  */
 void dispatch_emulation( ARM64_NT_CONTEXT *arm_ctx )
 {
-    context_arm_to_x64( get_arm64ec_cpu_area()->ContextAmd64, arm_ctx );
+    ARM64EC_NT_CONTEXT *context = get_arm64ec_cpu_area()->ContextAmd64;
+    CONTEXT_EX *xctx;
+
+    RtlInitializeExtendedContext( context, ctx_flags_arm_to_x64( arm_ctx->ContextFlags), &xctx );
+    context_arm_to_x64( context, arm_ctx );
     get_arm64ec_cpu_area()->InSimulation = 1;
     pBeginSimulation();
 }
@@ -1250,11 +1259,13 @@ static void dispatch_syscall( ARM64_NT_CONTEXT *context )
 }
 
 
-static void * __attribute__((used)) prepare_exception_arm64ec( EXCEPTION_RECORD *rec, ARM64EC_NT_CONTEXT *context, ARM64_NT_CONTEXT *arm_ctx )
+static void * __attribute__((used)) prepare_exception_arm64ec( EXCEPTION_RECORD *rec, union ARM64EC_NT_XCONTEXT *context, ARM64_NT_CONTEXT *arm_ctx )
 {
+    CONTEXT_EX *xctx;
     if (rec->ExceptionCode == STATUS_EMULATION_SYSCALL) dispatch_syscall( arm_ctx );
-    context_arm_to_x64( context, arm_ctx );
-    if (pResetToConsistentState) pResetToConsistentState( rec, &context->AMD64_Context, arm_ctx );
+    RtlInitializeExtendedContext( context, ctx_flags_arm_to_x64( arm_ctx->ContextFlags ), &xctx );
+    context_arm_to_x64( &context->context, arm_ctx );
+    if (pResetToConsistentState) pResetToConsistentState( rec, &context->context.AMD64_Context, arm_ctx );
     /* call x64 dispatcher if the thunk or the function pointer was modified */
     if (pWow64PrepareForException || memcmp( KiUserExceptionDispatcher_thunk, KiUserExceptionDispatcher_orig,
                                              sizeof(KiUserExceptionDispatcher_orig) ))
@@ -1269,12 +1280,13 @@ void __attribute__((naked)) KiUserExceptionDispatcher( EXCEPTION_RECORD *rec, CO
 {
     asm( ".seh_proc \"#KiUserExceptionDispatcher\"\n\t"
          ".seh_context\n\t"
-         "sub sp, sp, #0x4d0\n\t"       /* sizeof(ARM64EC_NT_CONTEXT) */
-         ".seh_stackalloc 0x4d0\n\t"
+         "sub sp, sp, #0xcd0\n\t"       /* sizeof(union ARM64EC_NT_XCONTEXT) */
+         ".seh_stackalloc 0xcd0\n\t"
          ".seh_endprologue\n\t"
-         "add x0, sp, #0x3b0+0x4d0\n\t" /* rec */
+         "add x0, sp, #0xcd0\n\t"
+         "add x0, x0, #0x3b0\n\t"       /* rec */
          "mov x1, sp\n\t"               /* context */
-         "add x2, sp, #0x4d0\n\t"       /* arm_ctx (context + 1) */
+         "add x2, sp, #0xcd0\n\t"       /* arm_ctx (context + 1) */
          "bl \"#prepare_exception_arm64ec\"\n\t"
          "cbz x0, 1f\n\t"
          /* bypass exit thunk to avoid messing up the stack */
@@ -1282,8 +1294,9 @@ void __attribute__((naked)) KiUserExceptionDispatcher( EXCEPTION_RECORD *rec, CO
          "ldr x16, [x16, #:lo12:__os_arm64x_dispatch_call_no_redirect]\n\t"
          "mov x9, x0\n\t"
          "blr x16\n"
-         "1:\tadd x0, sp, #0x3b0+0x4d0\n\t" /* rec */
-         "mov x1, sp\n\t"                   /* context */
+         "1:\tadd x0, sp, #0xcd0\n\t"
+         "add x0, x0, #0x3b0\n\t"       /* rec */
+         "mov x1, sp\n\t"               /* context */
          "bl #dispatch_exception\n\t"
          "brk #1\n\t"
          ".seh_endproc" );
@@ -1297,11 +1310,12 @@ static void __attribute__((used)) dispatch_apc( void (CALLBACK *func)(ULONG_PTR,
                                                 ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3,
                                                 BOOLEAN alertable, ARM64_NT_CONTEXT *arm_ctx )
 {
-    ARM64EC_NT_CONTEXT context;
-
-    context_arm_to_x64( &context, arm_ctx );
-    func( arg1, arg2, arg3, &context.AMD64_Context );
-    NtContinue( &context.AMD64_Context, alertable );
+    union ARM64EC_NT_XCONTEXT context;
+    CONTEXT_EX *xctx;
+    RtlInitializeExtendedContext( &context, ctx_flags_arm_to_x64( arm_ctx->ContextFlags), &xctx );
+    context_arm_to_x64( &context.context, arm_ctx );
+    func( arg1, arg2, arg3, &context.context.AMD64_Context );
+    NtContinue( &context.context.AMD64_Context, alertable );
 }
 __ASM_GLOBAL_FUNC( "#KiUserApcDispatcher",
                    ".seh_context\n\t"
@@ -2056,7 +2070,9 @@ void __attribute__((naked)) RtlUserThreadStart( PRTL_THREAD_START_ROUTINE entry,
  */
 void WINAPI LdrInitializeThunk( CONTEXT *arm_context, ULONG_PTR unk2, ULONG_PTR unk3, ULONG_PTR unk4 )
 {
-    ARM64EC_NT_CONTEXT context;
+    union ARM64EC_NT_XCONTEXT context;
+    CONTEXT_EX *xctx;
+    RtlInitializeExtendedContext( &context, ctx_flags_arm_to_x64( arm_context->ContextFlags), &xctx );
 
     if (!__os_arm64x_check_call)
     {
@@ -2067,10 +2083,10 @@ void WINAPI LdrInitializeThunk( CONTEXT *arm_context, ULONG_PTR unk2, ULONG_PTR
         __os_arm64x_set_x64_information = LdrpSetX64Information;
     }
 
-    context_arm_to_x64( &context, (ARM64_NT_CONTEXT *)arm_context );
-    loader_init( &context.AMD64_Context, (void **)&context.X0 );
-    TRACE_(relay)( "\1Starting thread proc %p (arg=%p)\n", (void *)context.X0, (void *)context.X1 );
-    NtContinue( &context.AMD64_Context, TRUE );
+    context_arm_to_x64( &context.context, (ARM64_NT_CONTEXT *)arm_context );
+    loader_init( &context.context.AMD64_Context, (void **)&context.context.X0 );
+    TRACE_(relay)( "\1Starting thread proc %p (arg=%p)\n", (void *)context.context.X0, (void *)context.context.X1 );
+    NtContinue( &context.context.AMD64_Context, TRUE );
 }
 
 
diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
index 2e5980529cac..41a3c612c62b 100644
--- a/dlls/ntdll/signal_x86_64.c
+++ b/dlls/ntdll/signal_x86_64.c
@@ -83,7 +83,7 @@ __ASM_GLOBAL_FUNC( "EXP+#KiUserExceptionDispatcher",
                    "test %rax,%rax\n\t"
                    "jz 1f\n\t"
                    "subq $0x28,%rsp\n\t"
-                   "leaq 0x30+0x3b0+0x4d0(%rsp),%rcx\n\t" /* rec */
+                   "leaq 0x30+0x3b0+0xcd0(%rsp),%rcx\n\t" /* rec */
                    "leaq 0x30(%rsp),%rdx\n\t"             /* context */
                    "call *%rax\n"
                    "addq $0x28,%rsp\n"
diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
index e486da406918..78414049182e 100644
--- a/dlls/ntdll/unix/system.c
+++ b/dlls/ntdll/unix/system.c
@@ -597,6 +597,23 @@ static ULONGLONG get_cpu_features(void)
     return 0;  /* FIXME */
 }
 
+static void init_xstate_features( XSTATE_CONFIGURATION *xstate )
+{
+    xstate->EnabledFeatures = (1 << XSTATE_LEGACY_FLOATING_POINT) | (1 << XSTATE_LEGACY_SSE) | (1 << XSTATE_AVX);
+    xstate->EnabledVolatileFeatures = xstate->EnabledFeatures;
+    xstate->AllFeatureSize = 0x340;
+
+    xstate->OptimizedSave = 0;
+    xstate->CompactionEnabled = 0;
+
+    xstate->Features[0].Size = xstate->AllFeatures[0] = offsetof(XSAVE_FORMAT, XmmRegisters);
+    xstate->Features[1].Size = xstate->AllFeatures[1] = sizeof(M128A) * 16;
+    xstate->Features[1].Offset = xstate->Features[0].Size;
+    xstate->Features[2].Offset = 0x240;
+    xstate->Features[2].Size = 0x100;
+    xstate->Size = 0x340;
+}
+
 void init_shared_data_cpuinfo( KUSER_SHARED_DATA *data )
 {
     BOOLEAN *features = data->ProcessorFeatures;
@@ -679,6 +696,8 @@ void init_shared_data_cpuinfo( KUSER_SHARED_DATA *data )
             break;
         }
     }
+
+    init_xstate_features( &data->XState );
 }
 
 #endif /* End architecture specific feature detection for CPUs */
diff --git a/dlls/ntdll/unwind.h b/dlls/ntdll/unwind.h
index faca8a259fb6..71a4d23da043 100644
--- a/dlls/ntdll/unwind.h
+++ b/dlls/ntdll/unwind.h
@@ -36,6 +36,7 @@ static inline ULONG ctx_flags_x64_to_arm( ULONG flags )
     if (flags & CONTEXT_AMD64_CONTROL) ret |= CONTEXT_ARM64_CONTROL;
     if (flags & CONTEXT_AMD64_INTEGER) ret |= CONTEXT_ARM64_INTEGER;
     if (flags & CONTEXT_AMD64_FLOATING_POINT) ret |= CONTEXT_ARM64_FLOATING_POINT;
+    if (flags & CONTEXT_AMD64_XSTATE) ret |= CONTEXT_ARM64_FEX_YMMSTATE;
     return ret;
 }
 
@@ -47,6 +48,7 @@ static inline ULONG ctx_flags_arm_to_x64( ULONG flags )
     if (flags & CONTEXT_ARM64_CONTROL) ret |= CONTEXT_AMD64_CONTROL;
     if (flags & CONTEXT_ARM64_INTEGER) ret |= CONTEXT_AMD64_INTEGER;
     if (flags & CONTEXT_ARM64_FLOATING_POINT) ret |= CONTEXT_AMD64_FLOATING_POINT;
+    if (flags & CONTEXT_ARM64_FEX_YMMSTATE) ret |= CONTEXT_AMD64_XSTATE;
     return ret;
 }
 
@@ -166,6 +168,13 @@ static inline void context_x64_to_arm( ARM64_NT_CONTEXT *arm_ctx, const ARM64EC_
     fpcsr = mxcsr_to_fpcsr( ec_ctx->AMD64_MxCsr );
     arm_ctx->Fpcr = fpcsr;
     arm_ctx->Fpsr = fpcsr >> 32;
+
+    if ((ec_ctx->ContextFlags & CONTEXT_XSTATE) == CONTEXT_XSTATE)
+    {
+        CONTEXT_EX *ec_xctx = (CONTEXT_EX *)(ec_ctx + 1);
+        YMMCONTEXT *ec_ymm = RtlLocateExtendedFeature( ec_xctx, XSTATE_AVX, NULL );
+        memcpy( arm_ctx->V + 16, ec_ymm, sizeof(*ec_ymm) );
+    }
 }
 
 static inline void context_arm_to_x64( ARM64EC_NT_CONTEXT *ec_ctx, const ARM64_NT_CONTEXT *arm_ctx )
@@ -216,6 +225,13 @@ static inline void context_arm_to_x64( ARM64EC_NT_CONTEXT *ec_ctx, const ARM64_N
     ec_ctx->X17_3 = arm_ctx->X17 >> 48;
 
     memcpy( ec_ctx->V, arm_ctx->V, sizeof(ec_ctx->V) );
+
+    if ((arm_ctx->ContextFlags & CONTEXT_ARM64_FEX_YMMSTATE) == CONTEXT_ARM64_FEX_YMMSTATE)
+    {
+        CONTEXT_EX *ec_xctx = (CONTEXT_EX *)(ec_ctx + 1);
+        YMMCONTEXT *ec_ymm = RtlLocateExtendedFeature( ec_xctx, XSTATE_AVX, NULL );
+        memcpy( ec_ymm, arm_ctx->V + 16, sizeof(*ec_ymm) );
+    }
 }
 
 #endif /* __aarch64__ || __arm64ec__ */
diff --git a/include/winnt.h b/include/winnt.h
index 9e64648ea7ab..a0a19a9175ee 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -1705,8 +1705,9 @@ typedef struct _KNONVOLATILE_CONTEXT_POINTERS
 #define CONTEXT_ARM64_INTEGER         (CONTEXT_ARM64 | 0x00000002)
 #define CONTEXT_ARM64_FLOATING_POINT  (CONTEXT_ARM64 | 0x00000004)
 #define CONTEXT_ARM64_DEBUG_REGISTERS (CONTEXT_ARM64 | 0x00000008)
-#define CONTEXT_ARM64_X18       (CONTEXT_ARM64 | 0x00000010)
-#define CONTEXT_ARM64_XSTATE    (CONTEXT_ARM64 | 0x00000020)
+#define CONTEXT_ARM64_X18             (CONTEXT_ARM64 | 0x00000010)
+#define CONTEXT_ARM64_XSTATE          (CONTEXT_ARM64 | 0x00000020)
+#define CONTEXT_ARM64_FEX_YMMSTATE   (CONTEXT_ARM64 | 0x00000040)
 #define CONTEXT_ARM64_FULL (CONTEXT_ARM64_CONTROL | CONTEXT_ARM64_INTEGER | CONTEXT_ARM64_FLOATING_POINT)
 #define CONTEXT_ARM64_ALL  (CONTEXT_ARM64_FULL | CONTEXT_ARM64_DEBUG_REGISTERS | CONTEXT_ARM64_X18)
 

From 24c1cdac56d102b57e892e362776b96d5fd205dc Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Wed, 17 Apr 2024 23:44:33 +0000
Subject: [PATCH 09/16] Use FEX wow64/ARM64EC dll names

---
 dlls/ntdll/loader.c  | 3 +--
 dlls/wow64/syscall.c | 2 +-
 loader/wine.inf.in   | 4 ++--
 3 files changed, 4 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 7a307b33f22b..c9a91f192b69 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -4223,7 +4223,7 @@ static void load_arm64ec_module(void)
     ULONG buffer[16];
     KEY_VALUE_PARTIAL_INFORMATION *info = (KEY_VALUE_PARTIAL_INFORMATION *)buffer;
     UNICODE_STRING nameW = RTL_CONSTANT_STRING( L"\\Registry\\Machine\\Software\\Microsoft\\Wow64\\amd64" );
-    WCHAR module[64] = L"C:\\windows\\system32\\xtajit64.dll";
+    WCHAR module[64] = L"C:\\windows\\system32\\libarm64ecfex.dll";
     OBJECT_ATTRIBUTES attr;
     WINE_MODREF *wm;
     NTSTATUS status;
@@ -4307,7 +4307,6 @@ static void init_wow64( CONTEXT *context )
     pWow64LdrpInitialize( context );
 }
 
-
 #else
 
 void *Wow64Transition = NULL;
diff --git a/dlls/wow64/syscall.c b/dlls/wow64/syscall.c
index fbc687cc02a2..a71945411c48 100644
--- a/dlls/wow64/syscall.c
+++ b/dlls/wow64/syscall.c
@@ -745,7 +745,7 @@ static const WCHAR *get_cpu_dll_name(void)
     {
     case IMAGE_FILE_MACHINE_I386:
         RtlInitUnicodeString( &nameW, L"\\Registry\\Machine\\Software\\Microsoft\\Wow64\\x86" );
-        ret = (native_machine == IMAGE_FILE_MACHINE_ARM64 ? L"xtajit.dll" : L"wow64cpu.dll");
+        ret = (native_machine == IMAGE_FILE_MACHINE_ARM64 ? L"libwow64fex.dll" : L"wow64cpu.dll");
         break;
     case IMAGE_FILE_MACHINE_ARMNT:
         RtlInitUnicodeString( &nameW, L"\\Registry\\Machine\\Software\\Microsoft\\Wow64\\arm" );
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 8e6956b3e9fd..551438c41b51 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -439,9 +439,9 @@ HKLM,%CurrentVersion%,"ProgramFilesDir (x86)",,"%16426%"
 HKLM,%CurrentVersion%,"CommonFilesDir (x86)",,"%16428%"
 HKLM,%CurrentVersion%,"ProgramFilesDir (Arm)",,"C:\Program Files (Arm)"
 HKLM,%CurrentVersion%,"CommonFilesDir (Arm)",,"C:\Program Files (Arm)\Common Files"
-HKLM,Software\Microsoft\Wow64\amd64,,2,"xtajit64.dll"
+HKLM,Software\Microsoft\Wow64\amd64,,2,"libarm64ecfex.dll"
 HKLM,Software\Microsoft\Wow64\arm,,2,"wowarmhw.dll"
-HKLM,Software\Microsoft\Wow64\x86,,2,"xtajit.dll"
+HKLM,Software\Microsoft\Wow64\x86,,2,"libwow64fex.dll"
 
 [CurrentVersionWow64.ntx86]
 HKLM,%CurrentVersion%,"ProgramFilesDir (x86)",,"%16422%"

From 7dd0210b2f478ec3c95d7c95be01acc74b236702 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Tue, 1 Oct 2024 14:34:37 +0000
Subject: [PATCH 10/16] Avoid MS-style inline ASM on i386 clang.

---
 dlls/dinput/dinput.c    | 4 ++--
 dlls/riched20/txthost.c | 6 +++---
 dlls/riched20/txtsrv.c  | 6 +++---
 3 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/dlls/dinput/dinput.c b/dlls/dinput/dinput.c
index f851e17a2448..0b65f667cc77 100644
--- a/dlls/dinput/dinput.c
+++ b/dlls/dinput/dinput.c
@@ -45,7 +45,7 @@ static inline struct dinput *impl_from_IDirectInput8W( IDirectInput8W *iface )
     return CONTAINING_RECORD( iface, struct dinput, IDirectInput8W_iface );
 }
 
-#if defined __i386__ && defined _MSC_VER
+#if defined __i386__ && defined _MSC_VER && !defined __clang__
 __declspec(naked) BOOL enum_callback_wrapper(void *callback, const void *instance, void *ref)
 {
     __asm
@@ -59,7 +59,7 @@ __declspec(naked) BOOL enum_callback_wrapper(void *callback, const void *instanc
         ret
     }
 }
-#elif defined __i386__ && defined __GNUC__
+#elif defined __i386__
 extern BOOL enum_callback_wrapper(void *callback, const void *instance, void *ref);
 __ASM_GLOBAL_FUNC( enum_callback_wrapper,
     "pushl %ebp\n\t"
diff --git a/dlls/riched20/txthost.c b/dlls/riched20/txthost.c
index 8ae804377733..6afd85ea200d 100644
--- a/dlls/riched20/txthost.c
+++ b/dlls/riched20/txthost.c
@@ -623,7 +623,7 @@ HRESULT __thiscall ITextHostImpl_TxGetHorzExtent( ITextHost2 *iface, LONG *horz_
 #ifdef __ASM_USE_THISCALL_WRAPPER
 
 #define STDCALL(func) (void *) __stdcall_ ## func
-#ifdef _MSC_VER
+#if defined(_MSC_VER) && !defined(__clang__)
 #define DEFINE_STDCALL_WRAPPER(num,func,args) \
     __declspec(naked) HRESULT __stdcall_##func(void) \
     { \
@@ -633,7 +633,7 @@ HRESULT __thiscall ITextHostImpl_TxGetHorzExtent( ITextHost2 *iface, LONG *horz_
         __asm mov eax, [ecx] \
         __asm jmp dword ptr [eax + 4*num] \
     }
-#else /* _MSC_VER */
+#else /* defined(_MSC_VER) && !defined(__clang__) */
 #define DEFINE_STDCALL_WRAPPER(num,func,args) \
    extern HRESULT __stdcall_ ## func(void); \
    __ASM_GLOBAL_FUNC(__stdcall_ ## func, \
@@ -642,7 +642,7 @@ HRESULT __thiscall ITextHostImpl_TxGetHorzExtent( ITextHost2 *iface, LONG *horz_
                    "pushl %eax\n\t" \
                    "movl (%ecx), %eax\n\t" \
                    "jmp *(4*(" #num "))(%eax)" )
-#endif /* _MSC_VER */
+#endif /* defined(_MSC_VER) && !defined(__clang__) */
 
 DEFINE_STDCALL_WRAPPER(3,ITextHostImpl_TxGetDC,4)
 DEFINE_STDCALL_WRAPPER(4,ITextHostImpl_TxReleaseDC,8)
diff --git a/dlls/riched20/txtsrv.c b/dlls/riched20/txtsrv.c
index 5c63b3daf9af..ef1189c9a8ad 100644
--- a/dlls/riched20/txtsrv.c
+++ b/dlls/riched20/txtsrv.c
@@ -483,7 +483,7 @@ HRESULT __thiscall fnTextSrv_TxGetCachedSize(ITextServices *iface, DWORD *pdwWid
 #ifdef __ASM_USE_THISCALL_WRAPPER
 
 #define STDCALL(func) (void *) __stdcall_ ## func
-#ifdef _MSC_VER
+#if defined(_MSC_VER) && !defined(__clang__)
 #define DEFINE_STDCALL_WRAPPER(num,func) \
     __declspec(naked) HRESULT __stdcall_##func(void) \
     { \
@@ -493,7 +493,7 @@ HRESULT __thiscall fnTextSrv_TxGetCachedSize(ITextServices *iface, DWORD *pdwWid
         __asm mov eax, [ecx] \
         __asm jmp dword ptr [eax + 4*num] \
     }
-#else /* _MSC_VER */
+#else /* defined(_MSC_VER) && !defined(__clang__) */
 #define DEFINE_STDCALL_WRAPPER(num,func) \
    extern HRESULT __stdcall_ ## func(void); \
    __ASM_GLOBAL_FUNC(__stdcall_ ## func, \
@@ -502,7 +502,7 @@ HRESULT __thiscall fnTextSrv_TxGetCachedSize(ITextServices *iface, DWORD *pdwWid
                    "pushl %eax\n\t" \
                    "movl (%ecx), %eax\n\t" \
                    "jmp *(4*(" #num "))(%eax)" )
-#endif /* _MSC_VER */
+#endif /* defined(_MSC_VER) && !defined(__clang__) */
 
 DEFINE_STDCALL_WRAPPER(3, ITextServices_TxSendMessage)
 DEFINE_STDCALL_WRAPPER(4, ITextServices_TxDraw)

From 8946754e1e32a347a1736cb59f0ba0bbbe9c7540 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Wed, 21 Aug 2024 22:27:49 +0000
Subject: [PATCH 11/16] ntdll: Setup the FEX SVE predicate reg after handling
 signals.

No WOA devices ship with SVE, so implementing this correctly by
preserving the SVE state in xstate isn't really viable for now so just
hardcode the FEX values.
---
 dlls/ntdll/unix/signal_arm64.c | 28 ++++++++++++++++++++++++++--
 1 file changed, 26 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/signal_arm64.c b/dlls/ntdll/unix/signal_arm64.c
index 9964d0a92242..2871a86b1071 100644
--- a/dlls/ntdll/unix/signal_arm64.c
+++ b/dlls/ntdll/unix/signal_arm64.c
@@ -84,10 +84,20 @@ WINE_DEFAULT_DEBUG_CHANNEL(seh);
 static struct _aarch64_ctx *get_extended_sigcontext( const ucontext_t *sigcontext, unsigned int magic )
 {
     struct _aarch64_ctx *ctx = (struct _aarch64_ctx *)sigcontext->uc_mcontext.__reserved;
-    while ((char *)ctx < (char *)(&sigcontext->uc_mcontext + 1) && ctx->magic && ctx->size)
+    BOOL extra = FALSE;
+    while ((extra || (char *)ctx < (char *)(&sigcontext->uc_mcontext + 1)) && ctx->magic && ctx->size)
     {
         if (ctx->magic == magic) return ctx;
-        ctx = (struct _aarch64_ctx *)((char *)ctx + ctx->size);
+
+        if (ctx->magic == EXTRA_MAGIC)
+        {
+            ctx = (struct _aarch64_ctx *)((struct extra_context *)ctx)->datap;
+            extra = TRUE;
+        }
+        else
+        {
+            ctx = (struct _aarch64_ctx *)((char *)ctx + ctx->size);
+        }
     }
     return NULL;
 }
@@ -97,6 +107,11 @@ static struct fpsimd_context *get_fpsimd_context( const ucontext_t *sigcontext )
     return (struct fpsimd_context *)get_extended_sigcontext( sigcontext, FPSIMD_MAGIC );
 }
 
+static struct sve_context *get_sve_context( const ucontext_t *sigcontext )
+{
+    return (struct sve_context *)get_extended_sigcontext( sigcontext, SVE_MAGIC );
+}
+
 static DWORD64 get_fault_esr( ucontext_t *sigcontext )
 {
     struct esr_context *esr = (struct esr_context *)get_extended_sigcontext( sigcontext, ESR_MAGIC );
@@ -1332,12 +1347,21 @@ static void usr2_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 #ifdef linux
     {
         struct fpsimd_context *fp = get_fpsimd_context( sigcontext );
+        struct sve_context *sve = get_sve_context( sigcontext );
         if (fp)
         {
             fp->fpcr = frame->fpcr;
             fp->fpsr = frame->fpsr;
             memcpy( fp->vregs, frame->v, sizeof(fp->vregs) );
         }
+
+        if (sve)
+        {
+            /* setup FEX SVE state */
+            ULONG64 vq = sve_vq_from_vl(sve->vl);
+            *(UINT16 *)((BYTE *)sve + SVE_SIG_PREG_OFFSET(vq, 2)) = 0x155;
+            *(UINT16 *)((BYTE *)sve + SVE_SIG_PREG_OFFSET(vq, 6)) = 0xffff;
+        }
     }
 #elif defined(__APPLE__)
     context->uc_mcontext->__ns.__fpcr = frame->fpcr;

From edb9b36ff2828023aab0fd32c887ac4d5bb21177 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Thu, 23 Jan 2025 01:04:14 +0000
Subject: [PATCH 12/16] ntdll: Add an interface to map the FEX stats shm.

---
 dlls/ntdll/unix/virtual.c | 53 +++++++++++++++++++++++++++++++++++++++
 include/winternl.h        |  7 ++++++
 2 files changed, 60 insertions(+)

diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index cb060605205c..7f3f4f59b7ac 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -241,6 +241,9 @@ static void *preload_reserve_end;
 static BOOL force_exec_prot;  /* whether to force PROT_EXEC on all PROT_READ mmaps */
 static BOOL enable_write_exceptions;  /* raise exception on writes to executable memory */
 
+#define FEX_STATS_SHM_MAX_SIZE 0x400000
+static void *fex_stats_shm;
+
 struct range_entry
 {
     void *base;
@@ -5890,6 +5893,49 @@ static unsigned int get_memory_image_info( HANDLE process, LPCVOID addr, MEMORY_
     return status;
 }
 
+#if defined(linux) && defined(__aarch64__)
+NTSTATUS get_memory_fex_stats_shm( HANDLE process, LPCVOID addr, MEMORY_FEX_STATS_SHM_INFORMATION *info,
+                                   SIZE_T len, SIZE_T *res_len)
+{
+    char buf[0x20];
+    int fd;
+    int oflag = O_RDWR;
+
+    if (len != sizeof(*info)) return STATUS_INFO_LENGTH_MISMATCH;
+    if (process != GetCurrentProcess()) return STATUS_INVALID_HANDLE;
+
+    sprintf( buf, "fex-%d-stats", getpid() );
+
+    if (!fex_stats_shm) {
+        fex_stats_shm = mmap( NULL, FEX_STATS_SHM_MAX_SIZE, PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS |
+                              MAP_NORESERVE, -1, 0 );
+        if (fex_stats_shm == MAP_FAILED) {
+            fex_stats_shm = NULL;
+            return STATUS_INTERNAL_ERROR;
+        }
+
+        oflag |= O_CREAT | O_TRUNC;
+    }
+
+    fd = shm_open( buf, oflag, S_IRWXU | S_IRWXG | S_IRWXO );
+    if (fd == -1) return STATUS_INTERNAL_ERROR;
+
+    if (ftruncate( fd, info->map_size )) goto err;
+
+    if (mmap( fex_stats_shm, info->map_size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, fd,
+              0 ) == MAP_FAILED) goto err;
+
+    close( fd );
+
+    info->shm_base = fex_stats_shm;
+    *res_len = len;
+    return STATUS_SUCCESS;
+
+err:
+    close( fd );
+    return STATUS_INTERNAL_ERROR;
+}
+#endif
 
 /***********************************************************************
  *             NtQueryVirtualMemory   (NTDLL.@)
@@ -5935,6 +5981,13 @@ NTSTATUS WINAPI NtQueryVirtualMemory( HANDLE process, LPCVOID addr,
             }
             return STATUS_INVALID_HANDLE;
 
+        case MemoryFexStatsShm:
+#if defined(linux) && defined(__aarch64__)
+            return get_memory_fex_stats_shm( process, addr, buffer, len, res_len );
+#else
+            FIXME("MemoryFexStatsShm unsupported\n");
+            break;
+#endif
         default:
             FIXME("(%p,%p,info_class=%d,%p,%ld,%p) Unknown information class\n",
                   process, addr, info_class, buffer, len, res_len);
diff --git a/include/winternl.h b/include/winternl.h
index 9bc5d0dac033..5cdb435c11a2 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -2313,6 +2313,7 @@ typedef enum _MEMORY_INFORMATION_CLASS {
     MemoryWineUnixFuncs = 1000,
     MemoryWineUnixWow64Funcs,
 #endif
+    MemoryFexStatsShm = 2000,
 } MEMORY_INFORMATION_CLASS;
 
 typedef struct _MEMORY_SECTION_NAME
@@ -2379,6 +2380,12 @@ typedef struct _MEMORY_IMAGE_INFORMATION
     };
 } MEMORY_IMAGE_INFORMATION, *PMEMORY_IMAGE_INFORMATION;
 
+typedef struct _MEMORY_FEX_STATS_SHM_INFORMATION
+{
+    void *shm_base;
+    SIZE_T map_size;
+} MEMORY_FEX_STATS_SHM_INFORMATION, *PMEMORY_FEX_STATS_SHM_INFORMATION;
+
 typedef enum _MUTANT_INFORMATION_CLASS
 {
     MutantBasicInformation

From d41dcbe25dcc707ffd3a110993e480053c5c8a1a Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Thu, 10 Jul 2025 16:09:08 +0100
Subject: [PATCH 13/16] ntdll: Add FEX specific Asahi TSO support

---
 dlls/ntdll/unix/process.c | 36 ++++++++++++++++++++++++++++++++++++
 include/winternl.h        |  1 +
 2 files changed, 37 insertions(+)

diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index 727b6dd9380b..1ff4fb2fcb85 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -46,6 +46,9 @@
 #ifdef HAVE_SYS_PARAM_H
 # include <sys/param.h>
 #endif
+#ifdef HAVE_SYS_PRCTL_H
+# include <sys/prctl.h>
+#endif
 #ifdef HAVE_SYS_QUEUE_H
 # include <sys/queue.h>
 #endif
@@ -1092,6 +1095,35 @@ void fill_vm_counters( VM_COUNTERS_EX *pvmi, int unix_pid )
 
 #endif
 
+static BOOL set_hardware_tso( BOOL enable ) {
+#ifdef HAVE_PRCTL
+#ifndef PR_GET_MEM_MODEL
+#define PR_GET_MEM_MODEL 0x6d4d444c
+#endif
+#ifndef PR_SET_MEM_MODEL
+#define PR_SET_MEM_MODEL 0x4d4d444c
+#endif
+#ifndef PR_SET_MEM_MODEL_DEFAULT
+#define PR_SET_MEM_MODEL_DEFAULT 0
+#endif
+#ifndef PR_SET_MEM_MODEL_TSO
+#define PR_SET_MEM_MODEL_TSO 1
+#endif
+    if (enable)
+    {
+        int ret = prctl( PR_GET_MEM_MODEL, 0, 0, 0, 0 );
+        if (ret == PR_SET_MEM_MODEL_DEFAULT)
+            return !prctl( PR_SET_MEM_MODEL, PR_SET_MEM_MODEL_TSO, 0, 0, 0 );
+        return ret == PR_SET_MEM_MODEL_TSO;
+    }
+
+    prctl( PR_SET_MEM_MODEL, PR_SET_MEM_MODEL_DEFAULT, 0, 0, 0 );
+    return TRUE;
+#else
+    return FALSE;
+#endif
+}
+
 #define UNIMPLEMENTED_INFO_CLASS(c) \
     case c: \
         FIXME( "(process=%p) Unimplemented information class: " #c "\n", handle); \
@@ -1859,6 +1891,10 @@ NTSTATUS WINAPI NtSetInformationProcess( HANDLE handle, PROCESSINFOCLASS class,
         SERVER_END_REQ;
         break;
 
+    case ProcessFexHardwareTso:
+        if (size != sizeof(BOOL)) return STATUS_INFO_LENGTH_MISMATCH;
+        return set_hardware_tso( *(BOOL *)info ) ? STATUS_SUCCESS : STATUS_NOT_SUPPORTED;
+
     case ProcessPowerThrottlingState:
         FIXME( "ProcessPowerThrottlingState - stub\n" );
         return STATUS_SUCCESS;
diff --git a/include/winternl.h b/include/winternl.h
index 5cdb435c11a2..12898d4f7357 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -1910,6 +1910,7 @@ typedef enum _PROCESSINFOCLASS {
     ProcessWineLdtCopy,
     ProcessWineGrantAdminToken,
 #endif
+    ProcessFexHardwareTso = 2000,
 } PROCESSINFOCLASS;
 
 #define MEM_EXECUTE_OPTION_DISABLE   0x01

From f487ae05e7074412ef538f6d4e5adf53811e5c95 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Thu, 10 Jul 2025 18:55:42 +0100
Subject: [PATCH 14/16] HACK: ntdll: Manually define exit thunks for
 mem{cpy/move/set}

---
 dlls/winecrt0/arm64ec.c | 41 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 41 insertions(+)

diff --git a/dlls/winecrt0/arm64ec.c b/dlls/winecrt0/arm64ec.c
index a3af06b380d4..a8c82facbdab 100644
--- a/dlls/winecrt0/arm64ec.c
+++ b/dlls/winecrt0/arm64ec.c
@@ -103,4 +103,45 @@ asm( "\t.section .rdata,\"dr\"\n"
      "\t.rva __os_arm64x_helper7\n"
      "\t.rva __os_arm64x_helper8\n" );
 
+/*
+ * HACK: Provide an exit thunk for memcpy/memmove/memset to work around
+ * https://github.com/llvm/llvm-project/issues/101355
+ */
+asm( "\t.def $iexit_thunk$cdecl$i8$i8i8i8; .scl 2; .type 32; .endef\n"
+     "\t.section .wowthk$aa,\"xr\",discard,$iexit_thunk$cdecl$i8$i8i8i8\n"
+     "\t.globl  $iexit_thunk$cdecl$i8$i8i8i8\n"
+     "\t.p2align 2\n"
+     "$iexit_thunk$cdecl$i8$i8i8i8:\n"
+     "\t.seh_proc $iexit_thunk$cdecl$i8$i8i8i8\n"
+     "\tsub     sp, sp, #48\n"
+     "\t.seh_stackalloc 48\n"
+     "\tstp     x29, x30, [sp, #32]\n"
+     "\t.seh_save_fplr 32\n"
+     "\tadd     x29, sp, #32\n"
+     "\t.seh_add_fp 32\n"
+     "\t.seh_endprologue\n"
+     "\tadrp    x8, __os_arm64x_dispatch_call_no_redirect\n"
+     "\tldr     x16, [x8, :lo12:__os_arm64x_dispatch_call_no_redirect]\n"
+     "\tblr     x16\n"
+     "\tmov     x0, x8\n"
+     "\t.seh_startepilogue\n"
+     "\tldp     x29, x30, [sp, #32]\n"
+     "\t.seh_save_fplr  32\n"
+     "\tadd     sp, sp, #48\n"
+     "\t.seh_stackalloc 48\n"
+     "\t.seh_endepilogue\n"
+     "\tret\n"
+     "\t.seh_endproc\n"
+
+     "\t.section .hybmp$x,\"yi\"\n"
+     "\t.symidx memcpy\n"
+     "\t.symidx $iexit_thunk$cdecl$i8$i8i8i8\n"
+     "\t.word 4\n"
+     "\t.symidx memmove\n"
+     "\t.symidx $iexit_thunk$cdecl$i8$i8i8i8\n"
+     "\t.word 4\n"
+     "\t.symidx memset\n"
+     "\t.symidx $iexit_thunk$cdecl$i8$i8i8i8\n"
+     "\t.word 4\n" );
+
 #endif /* __arm64ec__ */

From aea762e09d4b87353acd2e0b67b0bfa7b17fca3a Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Tue, 15 Jul 2025 17:09:15 +0100
Subject: [PATCH 15/16] HACK: Avoid delay importing rpcrt4

Works around broken variadic exit thunks.
---
 dlls/advapi32/Makefile.in | 4 ++--
 dlls/sechost/Makefile.in  | 3 +--
 2 files changed, 3 insertions(+), 4 deletions(-)

diff --git a/dlls/advapi32/Makefile.in b/dlls/advapi32/Makefile.in
index 57bb25feb9c6..671cb02fcd0c 100644
--- a/dlls/advapi32/Makefile.in
+++ b/dlls/advapi32/Makefile.in
@@ -1,8 +1,8 @@
 EXTRADEFS = -D_ADVAPI32_
 MODULE    = advapi32.dll
 IMPORTLIB = advapi32
-IMPORTS   = kernelbase sechost msvcrt
-DELAYIMPORTS = cryptsp rpcrt4 user32 userenv
+IMPORTS   = kernelbase sechost msvcrt rpcrt4
+DELAYIMPORTS = cryptsp user32 userenv
 
 SOURCES = \
 	advapi.c \
diff --git a/dlls/sechost/Makefile.in b/dlls/sechost/Makefile.in
index ec1eb100683c..25439e94090f 100644
--- a/dlls/sechost/Makefile.in
+++ b/dlls/sechost/Makefile.in
@@ -1,7 +1,6 @@
 MODULE    = sechost.dll
 IMPORTLIB = sechost
-IMPORTS   = kernelbase
-DELAYIMPORTS = rpcrt4
+IMPORTS   = kernelbase rpcrt4
 
 SOURCES = \
 	plugplay.idl \

From ff92282628ef21787b247211460f13bea8b70217 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Wed, 6 Aug 2025 21:56:24 +0100
Subject: [PATCH 16/16] ntdll: Implement FEX-specific kernel-side unaligned
 atomic handling.

---
 dlls/ntdll/unix/process.c | 15 +++++++++++++++
 include/winternl.h        |  6 ++++++
 2 files changed, 21 insertions(+)

diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index 1ff4fb2fcb85..06af5b780bf8 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -1124,6 +1124,17 @@ static BOOL set_hardware_tso( BOOL enable ) {
 #endif
 }
 
+static BOOL set_unalign_atomic_mode( ULONG64 flags ) {
+#ifdef HAVE_PRCTL
+#ifndef PR_ARM64_SET_UNALIGN_ATOMIC
+#define PR_ARM64_SET_UNALIGN_ATOMIC 0x46455849
+#endif
+    return !prctl( PR_ARM64_SET_UNALIGN_ATOMIC, flags, 0, 0, 0 );;
+#else
+    return FALSE;
+#endif
+}
+
 #define UNIMPLEMENTED_INFO_CLASS(c) \
     case c: \
         FIXME( "(process=%p) Unimplemented information class: " #c "\n", handle); \
@@ -1895,6 +1906,10 @@ NTSTATUS WINAPI NtSetInformationProcess( HANDLE handle, PROCESSINFOCLASS class,
         if (size != sizeof(BOOL)) return STATUS_INFO_LENGTH_MISMATCH;
         return set_hardware_tso( *(BOOL *)info ) ? STATUS_SUCCESS : STATUS_NOT_SUPPORTED;
 
+    case ProcessFexUnalignAtomic:
+        if (size != sizeof(ULONG64)) return STATUS_INFO_LENGTH_MISMATCH;
+        return set_unalign_atomic_mode( *(ULONG64 *)info ) ? STATUS_SUCCESS : STATUS_NOT_SUPPORTED;
+
     case ProcessPowerThrottlingState:
         FIXME( "ProcessPowerThrottlingState - stub\n" );
         return STATUS_SUCCESS;
diff --git a/include/winternl.h b/include/winternl.h
index 12898d4f7357..d710fd383b8f 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -1911,8 +1911,14 @@ typedef enum _PROCESSINFOCLASS {
     ProcessWineGrantAdminToken,
 #endif
     ProcessFexHardwareTso = 2000,
+    ProcessFexUnalignAtomic,
 } PROCESSINFOCLASS;
 
+// These match the prctl flag values
+#define FEX_UNALIGN_ATOMIC_EMULATE       (1ULL << 0)
+#define FEX_UNALIGN_ATOMIC_BACKPATCH     (1ULL << 1)
+#define FEX_UNALIGN_ATOMIC_STRICT_SPLIT_LOCKS    (1ULL << 2)
+
 #define MEM_EXECUTE_OPTION_DISABLE   0x01
 #define MEM_EXECUTE_OPTION_ENABLE    0x02
 #define MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION 0x04
